Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.

class Solution(object):
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        d={target-n:i for i,n in enumerate(nums)}
        for i in range(0,len(nums)-1):
            if nums[i] in d and i!=d[nums[i]]:
                return [i,d[nums[i]]]

Given an integer x, return true if x is a 
palindrome
, and false otherwise.

class Solution(object):
    def isPalindrome(self, x):
        """
        :type x: int
        :rtype: bool
        """
        if x<0:
            return False
        lst=[]
        while x!=0:
            digit=x%10
            lst.append(digit)
            x=x//10
        if lst==list(reversed(lst)):
            return True
        else:
            return False

Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9. 
X can be placed before L (50) and C (100) to make 40 and 90. 
C can be placed before D (500) and M (1000) to make 400 and 900.
Given a roman numeral, convert it to an integer.

class Solution(object):

    def romanToInt(self, s):
        """
        :type s: str
        :rtype: int
        """
        def string_sub(s, symbol):
            if s.endswith(symbol):
                return s[:-(len(symbol))]
            return s
        ans=0
        string=''
        value=[1,4,5,9,10,40,50,90,100,400,500,900,1000]
        three_symbol_nums = {
            "III": 3, "XXX": 30, ...
        }
        two_symbol_nums = {
            ...
        }
        one_sym


        symbol=['I','IV','V','IX','X','XL','L','XC','C','CD','D','CM','M']
        d={symbol[i]:value[i] for i in range(len(symbol))}
        for element in symbol:
            for i in [3, 2, 1]:
                print(element*i, s, ans)
                if s.endswith(element*i):
                    ans+=d[element]*i
                    s=string_sub(s,element*i)
        return ans

Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string "".

class Solution(object):
    def longestCommonPrefix(self, strs):
        """
        :type strs: List[str]
        :rtype: str
        """
        ans=''
        i=0
        if len(strs)>1:
            while i<min([len(element) for element in strs]):
                print(i)
                lst=[]
                j=0
                for string in strs:
                    if string!='':
                        lst.append(string[i])
                    else:
                        return ''
                while j+1 <len(lst):
                    print(j)
                    if lst[j]==lst[j+1]:
                        j+=1
                    else:
                        return ans
                if j==len(lst)-1:
                    ans+=lst[j]
                i+=1
            return ans
        else:
            return strs[0]

Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Every close bracket has a corresponding open bracket of the same type.

class Solution(object):
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """
        if s == '':
            return True
        if len(s) % 2 != 0:
            return False
        new_str = s.replace('()', '').replace('[]', '').replace('{}', '')
        if new_str == s:
            return False
        return self.isValid(new_str)

You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.

Merge nums1 and nums2 into a single array sorted in non-decreasing order.

The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.

class Solution(object):
    def merge(self, nums1, m, nums2, n):
        """
        :type nums1: List[int]
        :type m: int
        :type nums2: List[int]
        :type n: int
        :rtype: None Do not return anything, modify nums1 in-place instead.
        """
        for i in range(len(nums1)):
            if i>=m:
                nums1[i]=nums2[i-m]
        nums1=nums1.sort()

Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.

Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things:

Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.
Return k.

class Solution(object):
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        lst=[]
        i=0
        while i in range(len(nums)):
            if nums[i] in lst:
                nums.pop(i)
                i=i-1
            lst.append(nums[i])
            i+=1
        return len(nums)

Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.

Consider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:

Change the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums.
Return k.

class Solution(object):
    def removeElement(self, nums, val):
        """
        :type nums: List[int]
        :type val: int
        :rtype: int
        """
        i=0
        while i in range(len(nums)):
            if nums[i]==val:
                nums.pop(i)
                i=i-1
            i+=1
        return len(nums)

Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

class Solution(object):
    def strStr(self, haystack, needle):
        """
        :type haystack: str
        :type needle: str
        :rtype: int
        """
        if needle in haystack:
            i=0
            j=0
            empty_string=''
            while i<=len(haystack)-len(needle):
                print(i)
                j=i
                while j in range(i,len(needle)+i):
                    print(j)
                    empty_string+=haystack[j]
                    j+=1
                if empty_string==needle:
                    return i
                i+=1
                empty_string=''
        else:
            return -1

Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You must write an algorithm with O(log n) runtime complexity.

class Solution(object):
    def searchInsert(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        return self.helper(nums, target, 0)

    def helper(self, nums, target, nums_start_index):
        if len(nums) == 0:
            return nums_start_index
        middle_index = len(nums) // 2
        if nums[middle_index] == target:
            return middle_index + nums_start_index
        if nums[middle_index] > target:
            nums = nums[:middle_index]
            return self.helper(nums, target, nums_start_index)
        if nums[middle_index] < target:
            nums = nums[middle_index+1:]
            next_num_start_index = nums_start_index + middle_index + 1
            return self.helper(nums, target, next_num_start_index)

Given a string s consisting of words and spaces, return the length of the last word in the string.

A word is a maximal 
substring
 consisting of non-space characters only.

class Solution(object):
    def lengthOfLastWord(self, s):
        """
        :type s: str
        :rtype: int
        """
        alphabet=['A','a','B','b','C','c','D','d','E','e','F','f','G','g','H','h','I','i','J','j','K','k','L','l','M','m','N','n','O','o','P','p','Q','q','R','r','S','s','T','t','U','u','V','v','W','w','X','x','Y','y','Z','z']
        count=0
        while s.endswith(' '):
            s=s[:len(s)-1]
            print(s)
        for i in range(len(s)):
            if s[i] not in alphabet:
                count=0
            else:
                count+=1
        return count

You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.

Increment the large integer by one and return the resulting array of digits.

class Solution(object):
    def plusOne(self, digits):
        """
        :type digits: List[int]
        :rtype: List[int]
        """
        empty_string=''
        for element in digits:
            empty_string+=str(element)
        integer=int(empty_string)
        integer+=1
        string=str(integer)
        lst=[]
        for i in range(len(string)):
            lst.append(int(string[i]))
        return lst

Given a 0-indexed integer array nums of length n and an integer target, return the number of pairs (i, j) where 0 <= i < j < n and nums[i] + nums[j] < target.

class Solution(object):
    def countPairs(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        count = 0
        nums = sorted(nums)
        for i in range(len(nums) - 1):
            rest = nums[i+1:]
            middle_index = len(rest) // 2
            while len(rest) != 0:
                if nums[i] + rest[middle_index] >= target: 
                    rest = rest[:middle_index]
                    middle_index = len(rest) // 2
                else:
                    count += middle_index + 1
                    rest = rest[middle_index + 1:] 
                    middle_index = len(rest) // 2
        return count

Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.

class Solution(object):
    def countNegatives(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        lst = []
        m = len(grid)
        n = len(grid[0])
        i = m - 1
        j = 0
        count = 0
        while i >= 0 and j < n:
            if grid[i][j] >= 0:
                j += 1
            else:
                count += n - j
                i -= 1
        return count

You are given a 0-indexed integer array nums and a target element target.

A target index is an index i such that nums[i] == target.

Return a list of the target indices of nums after sorting nums in non-decreasing order. If there are no target indices, return an empty list. The returned list must be sorted in increasing order.

class Solution(object):
    def targetIndices(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        nums = sorted(nums)
        return sorted(self.helper(nums, target, 0))

    def helper(self, nums, target, start_index):
        if len(nums) == 0:
            return []
        middle_index = len(nums) // 2
        if nums[middle_index] == target:
            return [middle_index + start_index] + self.helper(nums[:middle_index], target, start_index) + self.helper(nums[middle_index + 1:], target, start_index + middle_index + 1)
        if nums[middle_index] > target:
            return self.helper(nums[:middle_index], target, start_index)
        if nums[middle_index] < target:
            return self.helper(nums[middle_index + 1:], target, start_index + middle_index + 1)

Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.

You must not use any built-in exponent function or operator.

For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.

class Solution(object):
    def mySqrt(self, x):
        """
        :type x: int
        :rtype: int
        """

        return self.helper(x, 0, x)

    def helper(self, upper, lower, x):
        mid_point = upper - (upper - lower) // 2
        if mid_point * mid_point < x:
            if (mid_point + 1) * (mid_point + 1) > x:
                return mid_point
            lower = mid_point
            return self.helper(upper, lower, x)
        if mid_point * mid_point == x:
            return mid_point
        if mid_point * mid_point > x:
            if (mid_point - 1) * (mid_point - 1) < x:
                return mid_point - 1
            upper = mid_point
            return self.helper(upper, lower, x)

Given two binary strings a and b, return their sum as a binary string.

class Solution(object):
    def addBinary(self, a, b):
        """
        :type a: str
        :type b: str
        :rtype: str
        """
        int_a = int(a)
        int_b = int(b)
        res = int_a + int_b
        count = 0
        coefficient = 10 ** count
        divisor = 10 
        ans = 2
        digit = len(str(res))
        while count <= digit:
            print(res)
            if str(res % divisor).startswith('6'):
                res -= 5 * coefficient
                if count < digit:
                    res += 2 * coefficient * 10
            if str(res % divisor).startswith('5'):
                res -= 4 * coefficient
                if count < digit:
                    res += 2 * coefficient * 10
            if str(res % divisor).startswith('4'):
                res -= 3 * coefficient
                if count < digit:
                    res +=  coefficient * 10
            if str(res % divisor).startswith('3'):
                res -= 2 * coefficient
                if count < digit:
                    res += coefficient * 10
            if str(res % divisor).startswith('2'):
                res += 8 * coefficient
                count += 1
                coefficient = 10 ** count
                divisor *= 10
            else:    
                count += 1
                coefficient = 10 ** count
                divisor *= 10
        res = str(res)
        return res

Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.

# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def deleteDuplicates(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if head is None:
            return None
        lst = [head.val]
        res = cur = ListNode(head.val)
        while head:
            print(lst)
            if head.val not in lst:
                lst.append(head.val)
                cur.next = head
                cur = cur.next
            if head.next is None:
                cur.next = None
            head = head.next
        return res

Given two integer arrays nums1 and nums2, return an array of their 
intersection
. Each element in the result must be unique and you may return the result in any order.

class Solution(object):
    def intersection(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """
        lst = []
        for element in nums1:
            if element in nums2:
                if element not in lst:
                    lst.append(element)
        return lst

You are climbing a staircase. It takes n steps to reach the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

class Solution(object):
    def climbStairs(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n == 1:
            return 1
        if n == 2:
            return 2
        return self.climbStairs(n - 1) + self.climbStairs(n - 2)

You are given an m x n binary matrix mat of 1's (representing soldiers) and 0's (representing civilians). The soldiers are positioned in front of the civilians. That is, all the 1's will appear to the left of all the 0's in each row.

A row i is weaker than a row j if one of the following is true:

The number of soldiers in row i is less than the number of soldiers in row j.
Both rows have the same number of soldiers and i < j.
Return the indices of the k weakest rows in the matrix ordered from weakest to strongest.

class Solution(object):
    def kWeakestRows(self, mat, k):
        """
        :type mat: List[List[int]]
        :type k: int
        :rtype: List[int]
        """
        m = len(mat)
        if m == 0:
            return []
        n = len(mat[0])
        counts = []
        for i in range(m):
            row = mat[i]
            count = 0
            start_index = 0
            end_index = n - 1
            while start_index <= end_index:
                middle_index = (start_index + end_index) // 2
                if row[middle_index] == 0:
                    end_index = middle_index - 1
                else:
                    if (end_index - start_index + 1) % 2 == 0:
                        count += (end_index - start_index + 1) // 2
                    else:
                        count += (end_index - start_index + 1) // 2 + 1
                    start_index = middle_index + 1
            counts.append((i, count))
        counts = sorted(counts, key=lambda x: (x[1], x[0]))
        return [i for i, _ in counts[:k]]

You are given an integer array nums of length n, and an integer array queries of length m.

Return an array answer of length m where answer[i] is the maximum size of a subsequence that you can take from nums such that the sum of its elements is less than or equal to queries[i].

A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.

class Solution(object):
    def answerQueries(self, nums, queries):
        """
        :type nums: List[int]
        :type queries: List[int]
        :rtype: List[int]
        """
        m = len(nums)
        n = len(queries)
        lst = []
        nums = sorted(nums) O(mlogm)
        for query in queries: O(n)
            lst += [self.helper(nums, len(nums) - 1, 0, query)] O(logm)
        return lst

    def helper(self, nums, upper, lower, query):
            middle_index = (upper + lower) // 2
            if upper < lower:
                return middle_index + 1
            if sum(nums[:middle_index + 1]) > query:
                return self.helper(nums, middle_index - 1, lower, query)
            elif sum(nums[:middle_index + 1]) == query:
                return middle_index + 1
            else:
                return self.helper(nums, upper, middle_index + 1, query)

Given an array nums sorted in non-decreasing order, return the maximum between the number of positive integers and the number of negative integers.

In other words, if the number of positive integers in nums is pos and the number of negative integers is neg, then return the maximum of pos and neg.
Note that 0 is neither positive nor negative.

class Solution(object):
    def maximumCount(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        pos_index = self.find_smallest_positive_index(len(nums) - 1, 0, nums)
        pos = len(nums) - pos_index
        neg = self.find_largest_negative_index(len(nums[:pos_index]) - 1, 0, nums[:pos_index])
        return pos if pos > neg else neg

        
    def find_smallest_positive_index(self, upper, lower, nums):
        middle_index = (upper + lower) // 2
        if upper < lower:
            return middle_index + 1
        if nums[middle_index] > 0:
            return self.find_smallest_positive_index(middle_index - 1, lower, nums)
        else:
            return self.find_smallest_positive_index(upper, middle_index + 1, nums)

    def find_largest_negative_index(self, upper, lower, nums):
        middle_index = (upper + lower) // 2
        if upper < lower:
            return middle_index + 1
        if nums[middle_index] >= 0:
            return self.find_largest_negative_index(middle_index - 1, lower, nums)
        else:
            return self.find_largest_negative_index(upper, middle_index + 1, nums)

Given two integer arrays arr1 and arr2, and the integer d, return the distance value between the two arrays.

The distance value is defined as the number of elements arr1[i] such that there is not any element arr2[j] where |arr1[i]-arr2[j]| <= d.

class Solution(object):
    def findTheDistanceValue(self, arr1, arr2, d):
        """
        :type arr1: List[int]
        :type arr2: List[int]
        :type d: int
        :rtype: int
        """
        res = 0
        arr2 = sorted(arr2)
        for arr1_elem in arr1:
            res += self.find_closest_element(arr1_elem, arr2, len(arr2) - 1, 0, d)
        return res
                
    def find_closest_element(self, arr1_elem, arr2, upper, lower, d):
        middle_index = (upper + lower) // 2
        if upper < lower:
            return 1
        if abs(arr1_elem - arr2[middle_index]) <= d:
            return 0
        if arr1_elem - arr2[middle_index] > 0:
            return self.find_closest_element(arr1_elem, arr2, upper, middle_index + 1, d)
        elif arr1_elem - arr2[middle_index] < 0:
            return self.find_closest_element(arr1_elem, arr2, middle_index - 1, lower, d)
        else:
            return 0

Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.

class Solution(object):
    def missingNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        nums = sorted(nums)
        if nums[0] != 0:
            return 0
        if nums[len(nums) - 1] != len(nums):
            return len(nums)
        return self.find_missing_number(nums, len(nums) - 1, 0)
    
    def find_missing_number(self, nums, upper, lower):
        middle_index = (upper + lower) // 2
        if upper < lower:
            return nums[middle_index] - 1
        if nums[middle_index] - nums[middle_index - 1] == 2:
            return nums[middle_index] - 1
        if middle_index + 1 == nums[middle_index] + 1:
            return self.find_missing_number(nums, upper, middle_index + 1)
        else:
            return self.find_missing_number(nums, middle_index - 1, lower)

You are given an array nums of non-negative integers. nums is considered special if there exists a number x such that there are exactly x numbers in nums that are greater than or equal to x.

Notice that x does not have to be an element in nums.

Return x if the array is special, otherwise, return -1. It can be proven that if nums is special, the value for x is unique.

class Solution(object):
    def specialArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        nums = sorted(nums)
        return self.find_x(nums, len(nums) - 1, 0)
    
    def find_x(self, nums, upper, lower):
        middle_index = (upper + lower) // 2
        if upper < lower:
            return -1
        if nums[middle_index] >= len(nums) - middle_index:
            if middle_index == 0:
                return len(nums)
            if middle_index == nums[len(nums) - 1]:
                return -1
            if nums[middle_index - 1] < len(nums) - middle_index:
                return len(nums) - middle_index
            else:
                return self.find_x(nums, middle_index - 1, lower)
        else:
            return self.find_x(nums, upper, middle_index + 1)

Given an array arr of positive integers sorted in a strictly increasing order, and an integer k.

Return the kth positive integer that is missing from this array.

class Solution(object):
    def findKthPositive(self, arr, k):
        """
        :type arr: List[int]
        :type k: int
        :rtype: int
        """
        return self.find_right_element(arr, len(arr) - 1, 0, k)
        
    def find_right_element(self, arr, upper, lower, k):
        middle_index = (upper + lower) // 2
        if upper < lower:
            return k + middle_index + 1
        if k > arr[middle_index] - middle_index - 1:
            if middle_index >= len(arr) - 1:
                return k + middle_index + 1
            return self.find_right_element(arr, upper, middle_index + 1, k)
        else:
            if middle_index <= 0:
                return range(arr[0])[k]
            return self.find_right_element(arr, middle_index - 1, lower, k)

Given two integer arrays nums1 and nums2, sorted in non-decreasing order, return the minimum integer common to both arrays. If there is no common integer amongst nums1 and nums2, return -1.

Note that an integer is said to be common to nums1 and nums2 if both arrays have at least one occurrence of that integer.

class Solution(object):
    def getCommon(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: int
        """
        i = 0
        j = self.get_j_index(nums1, nums2, len(nums2) - 1, 0)
        while i < len(nums1) and j < len(nums2):
            if nums1[i] == nums2[j]:
                return nums1[i]
            elif nums1[i] < nums2[j]:
                i += 1
            else:
                j += 1
        return -1

    def get_j_index(self, nums1, nums2, upper, lower):
        middle_index = (upper + lower) // 2
        if middle_index <= 0:
            return 0
        if middle_index >= len(nums2) - 1:
            return len(nums2) - 1
        if upper < lower:
            return middle_index
        if nums1[0] > nums2[middle_index]:
            if nums1[0] < nums2[middle_index + 1]:
                return middle_index
            return self.get_j_index(nums1, nums2, upper, middle_index + 1)
        else:
            return self.get_j_index(nums1, nums2, middle_index - 1, lower)

Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.

You must write an algorithm with O(log n) runtime complexity.

class Solution(object):
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        return self.search_target(nums, len(nums) - 1, 0, target)
    
    def search_target(self, nums, upper, lower, target):
        middle_index = (upper + lower) // 2
        if upper < lower:
            return -1
        if nums[middle_index] == target:
            return middle_index
        elif nums[middle_index] > target:
            return self.search_target(nums, middle_index - 1, lower, target)
        else:
            return self.search_target(nums, upper, middle_index + 1, target)

Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.

class Solution(object):
    def find_nums_2_index(self, nums1_element, nums2, upper, lower):
        middle_index = (upper + lower) // 2
        if upper < lower:
            return None
        if nums2[middle_index] > nums1_element:
            return self.find_nums_2_index(nums1_element, nums2, middle_index - 1, lower)
        if nums2[middle_index] < nums1_element:
            return self.find_nums_2_index(nums1_element, nums2, upper, middle_index + 1)
        return middle_index

    def intersect(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """
        from collections import Counter

        nums1_counter = Counter(nums1)
        nums2_counter = Counter(nums2)
        final_counter = Counter([])
        for num, count in nums1_counter.items():
            if num in nums2_counter:
                final_counter[num] = min(count, nums2_counter[num])
        return [
            result
            for num, count in final_counter.items()
            for result in [num] * count
        ]
        # lst= []
        # nums2 = sorted(nums2)
        # nums2_remain = [n for n in nums2]
        # for nums1_element in nums1:
        #     index = self.find_nums_2_index(nums1_element, nums2_remain, len(nums2_remain) - 1, 0)
        #     if index is None:
        #         continue
        #     nums2_remain = nums2_remain[:index] + nums2_remain[index + 1:]
        #     lst.append(nums1_element)
        #     if len(nums2_remain) == 0:
        #         break
        # return lst

We are playing the Guess Game. The game is as follows:

I pick a number from 1 to n. You have to guess which number I picked.

Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.

You call a pre-defined API int guess(int num), which returns three possible results:

-1: Your guess is higher than the number I picked (i.e. num > pick).
1: Your guess is lower than the number I picked (i.e. num < pick).
0: your guess is equal to the number I picked (i.e. num == pick).
Return the number that I picked.

# The guess API is already defined for you.
# @param num, your guess
# @return -1 if num is higher than the picked number
#          1 if num is lower than the picked number
#          otherwise return 0
# def guess(num):

class Solution(object):
    def guessNumber(self, n):
        """
        :type n: int
        :rtype: int
        """
        return self.guessed_number(n - 1, 0)
        
    def guessed_number(self, upper, lower):
        middle_index = (upper + lower) // 2
        if guess(middle_index + 1) == 1:
            return self.guessed_number(upper, middle_index + 1)
        elif guess(middle_index + 1) == -1:
            return self.guessed_number(middle_index - 1, lower)
        else:
            return middle_index + 1

Alice and Bob have a different total number of candies. You are given two integer arrays aliceSizes and bobSizes where aliceSizes[i] is the number of candies of the ith box of candy that Alice has and bobSizes[j] is the number of candies of the jth box of candy that Bob has.

Since they are friends, they would like to exchange one candy box each so that after the exchange, they both have the same total amount of candy. The total amount of candy a person has is the sum of the number of candies in each box they have.

Return an integer array answer where answer[0] is the number of candies in the box that Alice must exchange, and answer[1] is the number of candies in the box that Bob must exchange. If there are multiple answers, you may return any one of them. It is guaranteed that at least one answer exists.

class Solution(object):
    def fairCandySwap(self, aliceSizes, bobSizes):
        """
        :type aliceSizes: List[int]
        :type bobSizes: List[int]
        :rtype: List[int]
        """
        def find_target(bobSizes, target, upper, lower):
            middle_index = (upper + lower) // 2
            if upper < lower:
                return False
            if bobSizes[middle_index] > target:
                return find_target(bobSizes, target, middle_index - 1, lower)
            if bobSizes[middle_index] < target:
                return find_target(bobSizes, target, upper, middle_index + 1)
            return True
            
        bobSizes = sorted(bobSizes)
        aliceSizesSum = sum(aliceSizes)
        bobSizesSum = sum(bobSizes)
        diff = aliceSizesSum - bobSizesSum
        for aliceSizesElement in aliceSizes:
            target = aliceSizesElement - diff // 2
            found = find_target(bobSizes, target, len(bobSizes) - 1, 0)
            if found:
                return [aliceSizesElement, target]

Given the root of a complete binary tree, return the number of the nodes in the tree.

According to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.

Design an algorithm that runs in less than O(n) time complexity.

# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def countNodes(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if root is None:
            return 0
        if root.right is None and root.left is None:
            return 1
        def count_depth(root):
            if root is None:
                return 0
            return count_depth(root.left) + 1
            
        def return_nodes(root, depth):
            if depth == 0:
                return [root]
            return return_nodes(root.left, depth - 1) + return_nodes(root.right, depth - 1)

        def count_bottom_nodes(node_list, upper, lower):
            middle_index = (upper + lower) // 2
            if upper < lower:
                return middle_index * 2 + 2
            if node_list[middle_index].left is None:
                return count_bottom_nodes(node_list, middle_index - 1, lower)
            if node_list[middle_index].right is None:
                return middle_index * 2 + 1
            return count_bottom_nodes(node_list, upper, middle_index + 1)
        
        depth = count_depth(root)

        node_list = return_nodes(root, depth - 2)

        return 2 ** (depth - 1) - 1 + count_bottom_nodes(node_list, 2 ** (depth - 2) - 1, 0)

You are given an array of characters letters that is sorted in non-decreasing order, and a character target. There are at least two different characters in letters.

Return the smallest character in letters that is lexicographically greater than target. If such a character does not exist, return the first character in letters.

class Solution(object):
    def nextGreatestLetter(self, letters, target):
        """
        :type letters: List[str]
        :type target: str
        :rtype: str
        """

        def find_smallest_letter(upper, lower):
            middle_index = (upper + lower) // 2
            if upper < lower:
                if middle_index >= len(letters) - 1:
                    return letters[0]
                return letters[middle_index + 1]
            if letters[middle_index] > target:
                return find_smallest_letter(middle_index - 1, lower)
            if letters[middle_index] <= target:
                return find_smallest_letter(upper, middle_index + 1)
            
        return find_smallest_letter(len(letters) - 1, 0)

You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.

Given the integer n, return the number of complete rows of the staircase you will build.

class Solution(object):
    def arrangeCoins(self, n):
        """
        :type n: int
        :rtype: int
        """
        def find_level(upper, lower):
            middle = (upper + lower) // 2
            if upper < lower:
                return middle
            if middle * (1 + middle) / 2 < n:
                return find_level(upper, middle + 1)
            if middle * (1 + middle) // 2 > n:
                return find_level(middle - 1, lower)
            return middle

        return find_level(n, 0)

You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.

You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.

# The isBadVersion API is already defined for you.
# @param version, an integer
# @return a bool
# def isBadVersion(version):

class Solution(object):
    def firstBadVersion(self, n):
        """
        :type n: int
        :rtype: int
        """

        def find_first_bad(upper, lower):
            middle = (upper + lower) // 2
            if upper < lower:
                return middle + 1
            if isBadVersion(middle) == True:
                return find_first_bad(middle - 1, lower)
            if isBadVersion(middle) == False:
                return find_first_bad(upper, middle + 1)
        
        return find_first_bad(n, 1)

Given a positive integer num, return true if num is a perfect square or false otherwise.

A perfect square is an integer that is the square of an integer. In other words, it is the product of some integer with itself.

You must not use any built-in library function, such as sqrt.

class Solution(object):
    def isPerfectSquare(self, num):
        """
        :type num: int
        :rtype: bool
        """
        
        def find_square_root(upper, lower):
            middle = (upper + lower) // 2
            if upper < lower:
                return False
            if middle ** 2 < num:
                return find_square_root(upper, middle + 1)
            if middle ** 2 > num:
                return find_square_root(middle - 1, lower)
            return True

        return find_square_root(num, 0)

In the universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has n empty baskets, the ith basket is at position[i], Morty has m balls and needs to distribute the balls into the baskets such that the minimum magnetic force between any two balls is maximum.

Rick stated that magnetic force between two different balls at positions x and y is |x - y|.

Given the integer array position and the integer m. Return the required force.

class Solution(object):
    def maxDistance(self, position, m):
        """
        :type position: List[int]
        :type m: int
        :rtype: int
        """
        position = sorted(position)

        def find_minimum_ge_gap(gap, up, low):
            middle_index = (up + low) // 2
            # print(f"find_min_ge_gap: {middle_index=},{up=},{low=}, {gap=}")
            if low > len(position):
                return None
            if up < low:
                return low
            if position[middle_index] >= gap:
                return find_minimum_ge_gap(gap, middle_index - 1, low)
            return find_minimum_ge_gap(gap, up, middle_index + 1)
        
        
        def can_place_balls(i, gap, position, m):
            while m > 0:
                # print(f"can_place_balls: {i=},{gap=}")
                if i > len(position) - 1:
                    return False
                i = find_minimum_ge_gap(position[i] + gap, len(position) - 1, 1)
                if i is None:
                    return False
                m -= 1
            print('True')
            return True
        
        def find_gap(upper, lower):
            middle = (upper + lower) // 2
            # print(f"{upper=},{lower=},{middle=}")
            if upper < lower:
                return middle
            if can_place_balls(0, middle, position, m):
                return find_gap(upper, middle + 1)
            return find_gap(middle - 1, lower)
        
            
        # for gap in reversed(range(2, (position[-1])//(m - 1) + 1)):
        #     print(f"{gap=}")
        #     if can_place_balls(gap, position, m):
        #         return gap
        # return 1

        return find_gap((position[-1] - position[0]) // (m - 1), 2)

A conveyor belt has packages that must be shipped from one port to another within days days.

The ith package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.

Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within days days.

class Solution:
    def shipWithinDays(self, weights: List[int], days: int) -> int:
        max_cap = sum(weights)
        min_cap = max(weights)

        def days_required(cap):
            days = 1
            i = 0
            sum = 0
            while i < len(weights) - 1:
                sum += weights[i]
                if sum + weights[i + 1] > cap:
                    days += 1
                    sum = 0
                i += 1
            return days

        def find_capacity(upper, lower):
            middle = (upper + lower) // 2
            if upper < lower:
                return lower
            if days_required(middle) > days:
                return find_capacity(upper, middle + 1)
            return find_capacity(middle - 1, lower)
        
        return find_capacity(max_cap, min_cap)

Write an algorithm to determine if a number n is happy.

A happy number is a number defined by the following process:

Starting with any positive integer, replace the number by the sum of the squares of its digits.
Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.
Those numbers for which this process ends in 1 are happy.
Return true if n is a happy number, and false if not.

class Solution:
    def isHappy(self, n: int) -> bool:
        res = 0
        lst = []
        while n != 1:
            for i in range(len(str(n))):
                res += (int(str(n)[i])) ** 2
            print(f"{res=}")
            n = res
            if n in lst:
                return False
            lst.append(n)
            res = 0
        return True

Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        if head is None:
            return None
        lst = []
        while head:
            if head.val != val:
                lst.append(head.val)
            head = head.next
        if len(lst) == 0:
            return None
        res = cur = ListNode(lst[0])
        for i in range(1, len(lst)):
            cur.next = ListNode(lst[i])
            cur = cur.next
        return res

Given an integer num, repeatedly add all its digits until the result has only one digit, and return it.

class Solution:
    def addDigits(self, num: int) -> int:
        while len(str(num)) != 1:
            res = 0
            for i in range(len(str(num))):
                print(f"{i=},{num=}")
                res += int(str(num)[i])
            num = res
        return num

Write a function that reverses a string. The input string is given as an array of characters s.

You must do this by modifying the input array in-place with O(1) extra memory.

class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        s.reverse()

Given an integer n, return true if it is a power of two. Otherwise, return false.

An integer n is a power of two, if there exists an integer x such that n == 2x.

class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        if n == 0:
            return False
        if n == 1:
            return True
        if n % 2 == 0:
            while n % 2 == 0:
                n = n / 2
            if n == 1:
                return True
        return False

Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.

You must implement a solution with a linear runtime complexity and use only constant extra space.

class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        lst = []
        for element in nums:
            if element in lst:
                lst.remove(element)
            else:
                lst.append(element)
        return lst[0]

Given the head of a singly linked list, reverse the list, and return the reversed list.

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head is None:
            return None
        lst = []
        while head:
            lst.append(head.val)
            head = head.next
        lst.reverse()
        print(f"{lst=}")
        res = cur = ListNode(lst[0])
        for i in range(1, len(lst)):
            cur.next = ListNode(lst[i])
            cur = cur.next
        return res

Given an array nums of size n, return the majority element.

The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        dic = {}
        for element in nums:
            if element not in dic.keys():
                dic[element] = 1
            else:
                dic[element] += 1
            if dic[element] > len(nums) // 2:
                return element

A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.

Given a string s, return true if it is a palindrome, or false otherwise.

class Solution:
    def isPalindrome(self, s: str) -> bool:
        if s == " ":
            return True
        cap = ['7','5','6','3','4','9','8','1','2','0','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
        low = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
        s = s.lower()
        i = 0
        while i < len(s):
            if s[i] not in cap and s[i] not in low:
                s = s[:i] + s[i + 1:]
                # print(f"{s=}")
                i -= 1
            i += 1
        new_string = ''
        for i in range(len(s)):
            new_string = s[i] + new_string
        if s == new_string:
            return True
        else:
            return False

Given a callable function f(x, y) with a hidden formula and a value z, reverse engineer the formula and return all positive integer pairs x and y where f(x,y) == z. You may return the pairs in any order.

"""
   This is the custom function interface.
   You should not implement it, or speculate about its implementation
   class CustomFunction:
       # Returns f(x, y) for any given positive integers x and y.
       # Note that f(x, y) is increasing with respect to both x and y.
       # i.e. f(x, y) < f(x + 1, y), f(x, y) < f(x, y + 1)
       def f(self, x, y):
  
"""

class Solution:

    def findSolution(self, customfunction: 'CustomFunction', z: int) -> List[List[int]]:
        y = z
        x = 1
        lst = []
        while x <= z and y >= 1:
            value = customfunction.f(x,y)
            if value < z:
                x += 1
            elif value == z:
                lst.append([x,y])
                x += 1
                y -= 1
            else:
                y -= 1
        return lst

You are climbing a staircase. It takes n steps to reach the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

class Solution:
    def climbStairs(self, n: int) -> int:
        if n <= 3:
            return n
        p1 = 3
        p2 = 2
        cur = 0
        for _ in range(3,n):
            cur = p1 + p2
            p2 = p1
            p1 = cur
        return cur

Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        
        def is_mirror(left, right):
            if left is None and right is None:
                return True
            if left is None or right is None or left.val != right.val:
                return False
            return is_mirror(left.left, right.right) and is_mirror(left.right, right.left)
        
        return is_mirror(root, root)

Given the root of a binary tree, return the inorder traversal of its nodes' values.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        lst = []
        self.helper(root, lst)
        return lst
    
    def helper(self, root, lst):
        if root:
            self.helper(root.left, lst)
            lst.append(root.val)
            self.helper(root.right, lst)

Given the root of a binary tree, return its maximum depth.

A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1

Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        if not nums:
            return None
        mid = len(nums) // 2
        root = TreeNode(nums[mid])
        root.left = self.sortedArrayToBST(nums[:mid])
        root.right = self.sortedArrayToBST(nums[mid + 1:])
        return root

Given a binary tree, determine if it is height-balanced.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        
        def helper(root):
            if not root:
                return [True, 0]
            left_balanced, left_height = helper(root.left)
            right_balanced, right_height = helper(root.right)
            isBalanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1
            return [isBalanced, 1 + max(left_height, right_height)]
        
        return helper(root)[0]

Given an integer numRows, return the first numRows of Pascal's triangle.

class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        if numRows == 0:
            return []
        if numRows == 1:
            return [[1]]
        prev = self.generate(numRows - 1)
        new = [1] * numRows
        for i in range(1, numRows - 1):
            new[i] = prev[-1][i - 1] + prev[-1][i]
        prev.append(new)
        return prev

Given head, the head of a linked list, determine if the linked list has a cycle in it.

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        fast = head
        slow = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
            if slow == fast:
                return True
        return False

You are given an array prices where prices[i] is the price of a given stock on the ith day.

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        buy = prices[0]
        profit = 0

        for i in range(len(prices)):
            if prices[i] < buy:
                buy = prices[i]

            profit = max(profit, prices[i] - buy)

        return profit
