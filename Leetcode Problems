Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.

class Solution(object):
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        d={target-n:i for i,n in enumerate(nums)}
        for i in range(0,len(nums)-1):
            if nums[i] in d and i!=d[nums[i]]:
                return [i,d[nums[i]]]

Given an integer x, return true if x is a 
palindrome
, and false otherwise.

class Solution(object):
    def isPalindrome(self, x):
        """
        :type x: int
        :rtype: bool
        """
        if x<0:
            return False
        lst=[]
        while x!=0:
            digit=x%10
            lst.append(digit)
            x=x//10
        if lst==list(reversed(lst)):
            return True
        else:
            return False

Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9. 
X can be placed before L (50) and C (100) to make 40 and 90. 
C can be placed before D (500) and M (1000) to make 400 and 900.
Given a roman numeral, convert it to an integer.

class Solution(object):

    def romanToInt(self, s):
        """
        :type s: str
        :rtype: int
        """
        def string_sub(s, symbol):
            if s.endswith(symbol):
                return s[:-(len(symbol))]
            return s
        ans=0
        string=''
        value=[1,4,5,9,10,40,50,90,100,400,500,900,1000]
        three_symbol_nums = {
            "III": 3, "XXX": 30, ...
        }
        two_symbol_nums = {
            ...
        }
        one_sym


        symbol=['I','IV','V','IX','X','XL','L','XC','C','CD','D','CM','M']
        d={symbol[i]:value[i] for i in range(len(symbol))}
        for element in symbol:
            for i in [3, 2, 1]:
                print(element*i, s, ans)
                if s.endswith(element*i):
                    ans+=d[element]*i
                    s=string_sub(s,element*i)
        return ans

Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string "".

class Solution(object):
    def longestCommonPrefix(self, strs):
        """
        :type strs: List[str]
        :rtype: str
        """
        ans=''
        i=0
        if len(strs)>1:
            while i<min([len(element) for element in strs]):
                print(i)
                lst=[]
                j=0
                for string in strs:
                    if string!='':
                        lst.append(string[i])
                    else:
                        return ''
                while j+1 <len(lst):
                    print(j)
                    if lst[j]==lst[j+1]:
                        j+=1
                    else:
                        return ans
                if j==len(lst)-1:
                    ans+=lst[j]
                i+=1
            return ans
        else:
            return strs[0]

Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Every close bracket has a corresponding open bracket of the same type.

class Solution(object):
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """
        if s == '':
            return True
        if len(s) % 2 != 0:
            return False
        new_str = s.replace('()', '').replace('[]', '').replace('{}', '')
        if new_str == s:
            return False
        return self.isValid(new_str)

You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.

Merge nums1 and nums2 into a single array sorted in non-decreasing order.

The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.

class Solution(object):
    def merge(self, nums1, m, nums2, n):
        """
        :type nums1: List[int]
        :type m: int
        :type nums2: List[int]
        :type n: int
        :rtype: None Do not return anything, modify nums1 in-place instead.
        """
        for i in range(len(nums1)):
            if i>=m:
                nums1[i]=nums2[i-m]
        nums1=nums1.sort()

Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.

Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things:

Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.
Return k.

class Solution(object):
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        lst=[]
        i=0
        while i in range(len(nums)):
            if nums[i] in lst:
                nums.pop(i)
                i=i-1
            lst.append(nums[i])
            i+=1
        return len(nums)

Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.

Consider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:

Change the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums.
Return k.

class Solution(object):
    def removeElement(self, nums, val):
        """
        :type nums: List[int]
        :type val: int
        :rtype: int
        """
        i=0
        while i in range(len(nums)):
            if nums[i]==val:
                nums.pop(i)
                i=i-1
            i+=1
        return len(nums)

Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

class Solution(object):
    def strStr(self, haystack, needle):
        """
        :type haystack: str
        :type needle: str
        :rtype: int
        """
        if needle in haystack:
            i=0
            j=0
            empty_string=''
            while i<=len(haystack)-len(needle):
                print(i)
                j=i
                while j in range(i,len(needle)+i):
                    print(j)
                    empty_string+=haystack[j]
                    j+=1
                if empty_string==needle:
                    return i
                i+=1
                empty_string=''
        else:
            return -1

Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You must write an algorithm with O(log n) runtime complexity.

class Solution(object):
    def searchInsert(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        return self.helper(nums, target, 0)

    def helper(self, nums, target, nums_start_index):
        if len(nums) == 0:
            return nums_start_index
        middle_index = len(nums) // 2
        if nums[middle_index] == target:
            return middle_index + nums_start_index
        if nums[middle_index] > target:
            nums = nums[:middle_index]
            return self.helper(nums, target, nums_start_index)
        if nums[middle_index] < target:
            nums = nums[middle_index+1:]
            next_num_start_index = nums_start_index + middle_index + 1
            return self.helper(nums, target, next_num_start_index)

Given a string s consisting of words and spaces, return the length of the last word in the string.

A word is a maximal 
substring
 consisting of non-space characters only.

class Solution(object):
    def lengthOfLastWord(self, s):
        """
        :type s: str
        :rtype: int
        """
        alphabet=['A','a','B','b','C','c','D','d','E','e','F','f','G','g','H','h','I','i','J','j','K','k','L','l','M','m','N','n','O','o','P','p','Q','q','R','r','S','s','T','t','U','u','V','v','W','w','X','x','Y','y','Z','z']
        count=0
        while s.endswith(' '):
            s=s[:len(s)-1]
            print(s)
        for i in range(len(s)):
            if s[i] not in alphabet:
                count=0
            else:
                count+=1
        return count

You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.

Increment the large integer by one and return the resulting array of digits.

class Solution(object):
    def plusOne(self, digits):
        """
        :type digits: List[int]
        :rtype: List[int]
        """
        empty_string=''
        for element in digits:
            empty_string+=str(element)
        integer=int(empty_string)
        integer+=1
        string=str(integer)
        lst=[]
        for i in range(len(string)):
            lst.append(int(string[i]))
        return lst

Given a 0-indexed integer array nums of length n and an integer target, return the number of pairs (i, j) where 0 <= i < j < n and nums[i] + nums[j] < target.

class Solution(object):
    def countPairs(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        count = 0
        nums = sorted(nums)
        for i in range(len(nums) - 1):
            rest = nums[i+1:]
            middle_index = len(rest) // 2
            while len(rest) != 0:
                if nums[i] + rest[middle_index] >= target: 
                    rest = rest[:middle_index]
                    middle_index = len(rest) // 2
                else:
                    count += middle_index + 1
                    rest = rest[middle_index + 1:] 
                    middle_index = len(rest) // 2
        return count

Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.

class Solution(object):
    def countNegatives(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        lst = []
        m = len(grid)
        n = len(grid[0])
        i = m - 1
        j = 0
        count = 0
        while i >= 0 and j < n:
            if grid[i][j] >= 0:
                j += 1
            else:
                count += n - j
                i -= 1
        return count

You are given a 0-indexed integer array nums and a target element target.

A target index is an index i such that nums[i] == target.

Return a list of the target indices of nums after sorting nums in non-decreasing order. If there are no target indices, return an empty list. The returned list must be sorted in increasing order.

class Solution(object):
    def targetIndices(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        nums = sorted(nums)
        return sorted(self.helper(nums, target, 0))

    def helper(self, nums, target, start_index):
        if len(nums) == 0:
            return []
        middle_index = len(nums) // 2
        if nums[middle_index] == target:
            return [middle_index + start_index] + self.helper(nums[:middle_index], target, start_index) + self.helper(nums[middle_index + 1:], target, start_index + middle_index + 1)
        if nums[middle_index] > target:
            return self.helper(nums[:middle_index], target, start_index)
        if nums[middle_index] < target:
            return self.helper(nums[middle_index + 1:], target, start_index + middle_index + 1)

Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.

You must not use any built-in exponent function or operator.

For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.

class Solution(object):
    def mySqrt(self, x):
        """
        :type x: int
        :rtype: int
        """

        return self.helper(x, 0, x)

    def helper(self, upper, lower, x):
        mid_point = upper - (upper - lower) // 2
        if mid_point * mid_point < x:
            if (mid_point + 1) * (mid_point + 1) > x:
                return mid_point
            lower = mid_point
            return self.helper(upper, lower, x)
        if mid_point * mid_point == x:
            return mid_point
        if mid_point * mid_point > x:
            if (mid_point - 1) * (mid_point - 1) < x:
                return mid_point - 1
            upper = mid_point
            return self.helper(upper, lower, x)

Given two binary strings a and b, return their sum as a binary string.

class Solution(object):
    def addBinary(self, a, b):
        """
        :type a: str
        :type b: str
        :rtype: str
        """
        int_a = int(a)
        int_b = int(b)
        res = int_a + int_b
        count = 0
        coefficient = 10 ** count
        divisor = 10 
        ans = 2
        digit = len(str(res))
        while count <= digit:
            print(res)
            if str(res % divisor).startswith('6'):
                res -= 5 * coefficient
                if count < digit:
                    res += 2 * coefficient * 10
            if str(res % divisor).startswith('5'):
                res -= 4 * coefficient
                if count < digit:
                    res += 2 * coefficient * 10
            if str(res % divisor).startswith('4'):
                res -= 3 * coefficient
                if count < digit:
                    res +=  coefficient * 10
            if str(res % divisor).startswith('3'):
                res -= 2 * coefficient
                if count < digit:
                    res += coefficient * 10
            if str(res % divisor).startswith('2'):
                res += 8 * coefficient
                count += 1
                coefficient = 10 ** count
                divisor *= 10
            else:    
                count += 1
                coefficient = 10 ** count
                divisor *= 10
        res = str(res)
        return res

Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.

# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def deleteDuplicates(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if head is None:
            return None
        lst = [head.val]
        res = cur = ListNode(head.val)
        while head:
            print(lst)
            if head.val not in lst:
                lst.append(head.val)
                cur.next = head
                cur = cur.next
            if head.next is None:
                cur.next = None
            head = head.next
        return res

Given two integer arrays nums1 and nums2, return an array of their 
intersection
. Each element in the result must be unique and you may return the result in any order.

class Solution(object):
    def intersection(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """
        lst = []
        for element in nums1:
            if element in nums2:
                if element not in lst:
                    lst.append(element)
        return lst

You are climbing a staircase. It takes n steps to reach the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

class Solution(object):
    def climbStairs(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n == 1:
            return 1
        if n == 2:
            return 2
        return self.climbStairs(n - 1) + self.climbStairs(n - 2)

You are given an m x n binary matrix mat of 1's (representing soldiers) and 0's (representing civilians). The soldiers are positioned in front of the civilians. That is, all the 1's will appear to the left of all the 0's in each row.

A row i is weaker than a row j if one of the following is true:

The number of soldiers in row i is less than the number of soldiers in row j.
Both rows have the same number of soldiers and i < j.
Return the indices of the k weakest rows in the matrix ordered from weakest to strongest.

class Solution(object):
    def kWeakestRows(self, mat, k):
        """
        :type mat: List[List[int]]
        :type k: int
        :rtype: List[int]
        """
        m = len(mat)
        if m == 0:
            return []
        n = len(mat[0])
        counts = []
        for i in range(m):
            row = mat[i]
            count = 0
            start_index = 0
            end_index = n - 1
            while start_index <= end_index:
                middle_index = (start_index + end_index) // 2
                if row[middle_index] == 0:
                    end_index = middle_index - 1
                else:
                    if (end_index - start_index + 1) % 2 == 0:
                        count += (end_index - start_index + 1) // 2
                    else:
                        count += (end_index - start_index + 1) // 2 + 1
                    start_index = middle_index + 1
            counts.append((i, count))
        counts = sorted(counts, key=lambda x: (x[1], x[0]))
        return [i for i, _ in counts[:k]]

You are given an integer array nums of length n, and an integer array queries of length m.

Return an array answer of length m where answer[i] is the maximum size of a subsequence that you can take from nums such that the sum of its elements is less than or equal to queries[i].

A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.

class Solution(object):
    def answerQueries(self, nums, queries):
        """
        :type nums: List[int]
        :type queries: List[int]
        :rtype: List[int]
        """
        m = len(nums)
        n = len(queries)
        lst = []
        nums = sorted(nums) O(mlogm)
        for query in queries: O(n)
            lst += [self.helper(nums, len(nums) - 1, 0, query)] O(logm)
        return lst

    def helper(self, nums, upper, lower, query):
            middle_index = (upper + lower) // 2
            if upper < lower:
                return middle_index + 1
            if sum(nums[:middle_index + 1]) > query:
                return self.helper(nums, middle_index - 1, lower, query)
            elif sum(nums[:middle_index + 1]) == query:
                return middle_index + 1
            else:
                return self.helper(nums, upper, middle_index + 1, query)

Given an array nums sorted in non-decreasing order, return the maximum between the number of positive integers and the number of negative integers.

In other words, if the number of positive integers in nums is pos and the number of negative integers is neg, then return the maximum of pos and neg.
Note that 0 is neither positive nor negative.

class Solution(object):
    def maximumCount(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        pos_index = self.find_smallest_positive_index(len(nums) - 1, 0, nums)
        pos = len(nums) - pos_index
        neg = self.find_largest_negative_index(len(nums[:pos_index]) - 1, 0, nums[:pos_index])
        return pos if pos > neg else neg

        
    def find_smallest_positive_index(self, upper, lower, nums):
        middle_index = (upper + lower) // 2
        if upper < lower:
            return middle_index + 1
        if nums[middle_index] > 0:
            return self.find_smallest_positive_index(middle_index - 1, lower, nums)
        else:
            return self.find_smallest_positive_index(upper, middle_index + 1, nums)

    def find_largest_negative_index(self, upper, lower, nums):
        middle_index = (upper + lower) // 2
        if upper < lower:
            return middle_index + 1
        if nums[middle_index] >= 0:
            return self.find_largest_negative_index(middle_index - 1, lower, nums)
        else:
            return self.find_largest_negative_index(upper, middle_index + 1, nums)

Given two integer arrays arr1 and arr2, and the integer d, return the distance value between the two arrays.

The distance value is defined as the number of elements arr1[i] such that there is not any element arr2[j] where |arr1[i]-arr2[j]| <= d.

class Solution(object):
    def findTheDistanceValue(self, arr1, arr2, d):
        """
        :type arr1: List[int]
        :type arr2: List[int]
        :type d: int
        :rtype: int
        """
        res = 0
        arr2 = sorted(arr2)
        for arr1_elem in arr1:
            res += self.find_closest_element(arr1_elem, arr2, len(arr2) - 1, 0, d)
        return res
                
    def find_closest_element(self, arr1_elem, arr2, upper, lower, d):
        middle_index = (upper + lower) // 2
        if upper < lower:
            return 1
        if abs(arr1_elem - arr2[middle_index]) <= d:
            return 0
        if arr1_elem - arr2[middle_index] > 0:
            return self.find_closest_element(arr1_elem, arr2, upper, middle_index + 1, d)
        elif arr1_elem - arr2[middle_index] < 0:
            return self.find_closest_element(arr1_elem, arr2, middle_index - 1, lower, d)
        else:
            return 0

Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.

class Solution(object):
    def missingNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        nums = sorted(nums)
        if nums[0] != 0:
            return 0
        if nums[len(nums) - 1] != len(nums):
            return len(nums)
        return self.find_missing_number(nums, len(nums) - 1, 0)
    
    def find_missing_number(self, nums, upper, lower):
        middle_index = (upper + lower) // 2
        if upper < lower:
            return nums[middle_index] - 1
        if nums[middle_index] - nums[middle_index - 1] == 2:
            return nums[middle_index] - 1
        if middle_index + 1 == nums[middle_index] + 1:
            return self.find_missing_number(nums, upper, middle_index + 1)
        else:
            return self.find_missing_number(nums, middle_index - 1, lower)

You are given an array nums of non-negative integers. nums is considered special if there exists a number x such that there are exactly x numbers in nums that are greater than or equal to x.

Notice that x does not have to be an element in nums.

Return x if the array is special, otherwise, return -1. It can be proven that if nums is special, the value for x is unique.

class Solution(object):
    def specialArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        nums = sorted(nums)
        return self.find_x(nums, len(nums) - 1, 0)
    
    def find_x(self, nums, upper, lower):
        middle_index = (upper + lower) // 2
        if upper < lower:
            return -1
        if nums[middle_index] >= len(nums) - middle_index:
            if middle_index == 0:
                return len(nums)
            if middle_index == nums[len(nums) - 1]:
                return -1
            if nums[middle_index - 1] < len(nums) - middle_index:
                return len(nums) - middle_index
            else:
                return self.find_x(nums, middle_index - 1, lower)
        else:
            return self.find_x(nums, upper, middle_index + 1)

Given an array arr of positive integers sorted in a strictly increasing order, and an integer k.

Return the kth positive integer that is missing from this array.

class Solution(object):
    def findKthPositive(self, arr, k):
        """
        :type arr: List[int]
        :type k: int
        :rtype: int
        """
        return self.find_right_element(arr, len(arr) - 1, 0, k)
        
    def find_right_element(self, arr, upper, lower, k):
        middle_index = (upper + lower) // 2
        if upper < lower:
            return k + middle_index + 1
        if k > arr[middle_index] - middle_index - 1:
            if middle_index >= len(arr) - 1:
                return k + middle_index + 1
            return self.find_right_element(arr, upper, middle_index + 1, k)
        else:
            if middle_index <= 0:
                return range(arr[0])[k]
            return self.find_right_element(arr, middle_index - 1, lower, k)

Given two integer arrays nums1 and nums2, sorted in non-decreasing order, return the minimum integer common to both arrays. If there is no common integer amongst nums1 and nums2, return -1.

Note that an integer is said to be common to nums1 and nums2 if both arrays have at least one occurrence of that integer.

class Solution(object):
    def getCommon(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: int
        """
        i = 0
        j = self.get_j_index(nums1, nums2, len(nums2) - 1, 0)
        while i < len(nums1) and j < len(nums2):
            if nums1[i] == nums2[j]:
                return nums1[i]
            elif nums1[i] < nums2[j]:
                i += 1
            else:
                j += 1
        return -1

    def get_j_index(self, nums1, nums2, upper, lower):
        middle_index = (upper + lower) // 2
        if middle_index <= 0:
            return 0
        if middle_index >= len(nums2) - 1:
            return len(nums2) - 1
        if upper < lower:
            return middle_index
        if nums1[0] > nums2[middle_index]:
            if nums1[0] < nums2[middle_index + 1]:
                return middle_index
            return self.get_j_index(nums1, nums2, upper, middle_index + 1)
        else:
            return self.get_j_index(nums1, nums2, middle_index - 1, lower)

Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.

You must write an algorithm with O(log n) runtime complexity.

class Solution(object):
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        return self.search_target(nums, len(nums) - 1, 0, target)
    
    def search_target(self, nums, upper, lower, target):
        middle_index = (upper + lower) // 2
        if upper < lower:
            return -1
        if nums[middle_index] == target:
            return middle_index
        elif nums[middle_index] > target:
            return self.search_target(nums, middle_index - 1, lower, target)
        else:
            return self.search_target(nums, upper, middle_index + 1, target)

Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.

class Solution(object):
    def find_nums_2_index(self, nums1_element, nums2, upper, lower):
        middle_index = (upper + lower) // 2
        if upper < lower:
            return None
        if nums2[middle_index] > nums1_element:
            return self.find_nums_2_index(nums1_element, nums2, middle_index - 1, lower)
        if nums2[middle_index] < nums1_element:
            return self.find_nums_2_index(nums1_element, nums2, upper, middle_index + 1)
        return middle_index

    def intersect(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """
        from collections import Counter

        nums1_counter = Counter(nums1)
        nums2_counter = Counter(nums2)
        final_counter = Counter([])
        for num, count in nums1_counter.items():
            if num in nums2_counter:
                final_counter[num] = min(count, nums2_counter[num])
        return [
            result
            for num, count in final_counter.items()
            for result in [num] * count
        ]
        # lst= []
        # nums2 = sorted(nums2)
        # nums2_remain = [n for n in nums2]
        # for nums1_element in nums1:
        #     index = self.find_nums_2_index(nums1_element, nums2_remain, len(nums2_remain) - 1, 0)
        #     if index is None:
        #         continue
        #     nums2_remain = nums2_remain[:index] + nums2_remain[index + 1:]
        #     lst.append(nums1_element)
        #     if len(nums2_remain) == 0:
        #         break
        # return lst

We are playing the Guess Game. The game is as follows:

I pick a number from 1 to n. You have to guess which number I picked.

Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.

You call a pre-defined API int guess(int num), which returns three possible results:

-1: Your guess is higher than the number I picked (i.e. num > pick).
1: Your guess is lower than the number I picked (i.e. num < pick).
0: your guess is equal to the number I picked (i.e. num == pick).
Return the number that I picked.

# The guess API is already defined for you.
# @param num, your guess
# @return -1 if num is higher than the picked number
#          1 if num is lower than the picked number
#          otherwise return 0
# def guess(num):

class Solution(object):
    def guessNumber(self, n):
        """
        :type n: int
        :rtype: int
        """
        return self.guessed_number(n - 1, 0)
        
    def guessed_number(self, upper, lower):
        middle_index = (upper + lower) // 2
        if guess(middle_index + 1) == 1:
            return self.guessed_number(upper, middle_index + 1)
        elif guess(middle_index + 1) == -1:
            return self.guessed_number(middle_index - 1, lower)
        else:
            return middle_index + 1

Alice and Bob have a different total number of candies. You are given two integer arrays aliceSizes and bobSizes where aliceSizes[i] is the number of candies of the ith box of candy that Alice has and bobSizes[j] is the number of candies of the jth box of candy that Bob has.

Since they are friends, they would like to exchange one candy box each so that after the exchange, they both have the same total amount of candy. The total amount of candy a person has is the sum of the number of candies in each box they have.

Return an integer array answer where answer[0] is the number of candies in the box that Alice must exchange, and answer[1] is the number of candies in the box that Bob must exchange. If there are multiple answers, you may return any one of them. It is guaranteed that at least one answer exists.

class Solution(object):
    def fairCandySwap(self, aliceSizes, bobSizes):
        """
        :type aliceSizes: List[int]
        :type bobSizes: List[int]
        :rtype: List[int]
        """
        def find_target(bobSizes, target, upper, lower):
            middle_index = (upper + lower) // 2
            if upper < lower:
                return False
            if bobSizes[middle_index] > target:
                return find_target(bobSizes, target, middle_index - 1, lower)
            if bobSizes[middle_index] < target:
                return find_target(bobSizes, target, upper, middle_index + 1)
            return True
            
        bobSizes = sorted(bobSizes)
        aliceSizesSum = sum(aliceSizes)
        bobSizesSum = sum(bobSizes)
        diff = aliceSizesSum - bobSizesSum
        for aliceSizesElement in aliceSizes:
            target = aliceSizesElement - diff // 2
            found = find_target(bobSizes, target, len(bobSizes) - 1, 0)
            if found:
                return [aliceSizesElement, target]

Given the root of a complete binary tree, return the number of the nodes in the tree.

According to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.

Design an algorithm that runs in less than O(n) time complexity.

# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def countNodes(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if root is None:
            return 0
        if root.right is None and root.left is None:
            return 1
        def count_depth(root):
            if root is None:
                return 0
            return count_depth(root.left) + 1
            
        def return_nodes(root, depth):
            if depth == 0:
                return [root]
            return return_nodes(root.left, depth - 1) + return_nodes(root.right, depth - 1)

        def count_bottom_nodes(node_list, upper, lower):
            middle_index = (upper + lower) // 2
            if upper < lower:
                return middle_index * 2 + 2
            if node_list[middle_index].left is None:
                return count_bottom_nodes(node_list, middle_index - 1, lower)
            if node_list[middle_index].right is None:
                return middle_index * 2 + 1
            return count_bottom_nodes(node_list, upper, middle_index + 1)
        
        depth = count_depth(root)

        node_list = return_nodes(root, depth - 2)

        return 2 ** (depth - 1) - 1 + count_bottom_nodes(node_list, 2 ** (depth - 2) - 1, 0)

You are given an array of characters letters that is sorted in non-decreasing order, and a character target. There are at least two different characters in letters.

Return the smallest character in letters that is lexicographically greater than target. If such a character does not exist, return the first character in letters.

class Solution(object):
    def nextGreatestLetter(self, letters, target):
        """
        :type letters: List[str]
        :type target: str
        :rtype: str
        """

        def find_smallest_letter(upper, lower):
            middle_index = (upper + lower) // 2
            if upper < lower:
                if middle_index >= len(letters) - 1:
                    return letters[0]
                return letters[middle_index + 1]
            if letters[middle_index] > target:
                return find_smallest_letter(middle_index - 1, lower)
            if letters[middle_index] <= target:
                return find_smallest_letter(upper, middle_index + 1)
            
        return find_smallest_letter(len(letters) - 1, 0)

You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.

Given the integer n, return the number of complete rows of the staircase you will build.

class Solution(object):
    def arrangeCoins(self, n):
        """
        :type n: int
        :rtype: int
        """
        def find_level(upper, lower):
            middle = (upper + lower) // 2
            if upper < lower:
                return middle
            if middle * (1 + middle) / 2 < n:
                return find_level(upper, middle + 1)
            if middle * (1 + middle) // 2 > n:
                return find_level(middle - 1, lower)
            return middle

        return find_level(n, 0)

You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.

You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.

# The isBadVersion API is already defined for you.
# @param version, an integer
# @return a bool
# def isBadVersion(version):

class Solution(object):
    def firstBadVersion(self, n):
        """
        :type n: int
        :rtype: int
        """

        def find_first_bad(upper, lower):
            middle = (upper + lower) // 2
            if upper < lower:
                return middle + 1
            if isBadVersion(middle) == True:
                return find_first_bad(middle - 1, lower)
            if isBadVersion(middle) == False:
                return find_first_bad(upper, middle + 1)
        
        return find_first_bad(n, 1)

Given a positive integer num, return true if num is a perfect square or false otherwise.

A perfect square is an integer that is the square of an integer. In other words, it is the product of some integer with itself.

You must not use any built-in library function, such as sqrt.

class Solution(object):
    def isPerfectSquare(self, num):
        """
        :type num: int
        :rtype: bool
        """
        
        def find_square_root(upper, lower):
            middle = (upper + lower) // 2
            if upper < lower:
                return False
            if middle ** 2 < num:
                return find_square_root(upper, middle + 1)
            if middle ** 2 > num:
                return find_square_root(middle - 1, lower)
            return True

        return find_square_root(num, 0)

In the universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has n empty baskets, the ith basket is at position[i], Morty has m balls and needs to distribute the balls into the baskets such that the minimum magnetic force between any two balls is maximum.

Rick stated that magnetic force between two different balls at positions x and y is |x - y|.

Given the integer array position and the integer m. Return the required force.

class Solution(object):
    def maxDistance(self, position, m):
        """
        :type position: List[int]
        :type m: int
        :rtype: int
        """
        position = sorted(position)

        def find_minimum_ge_gap(gap, up, low):
            middle_index = (up + low) // 2
            # print(f"find_min_ge_gap: {middle_index=},{up=},{low=}, {gap=}")
            if low > len(position):
                return None
            if up < low:
                return low
            if position[middle_index] >= gap:
                return find_minimum_ge_gap(gap, middle_index - 1, low)
            return find_minimum_ge_gap(gap, up, middle_index + 1)
        
        
        def can_place_balls(i, gap, position, m):
            while m > 0:
                # print(f"can_place_balls: {i=},{gap=}")
                if i > len(position) - 1:
                    return False
                i = find_minimum_ge_gap(position[i] + gap, len(position) - 1, 1)
                if i is None:
                    return False
                m -= 1
            print('True')
            return True
        
        def find_gap(upper, lower):
            middle = (upper + lower) // 2
            # print(f"{upper=},{lower=},{middle=}")
            if upper < lower:
                return middle
            if can_place_balls(0, middle, position, m):
                return find_gap(upper, middle + 1)
            return find_gap(middle - 1, lower)
        
            
        # for gap in reversed(range(2, (position[-1])//(m - 1) + 1)):
        #     print(f"{gap=}")
        #     if can_place_balls(gap, position, m):
        #         return gap
        # return 1

        return find_gap((position[-1] - position[0]) // (m - 1), 2)

A conveyor belt has packages that must be shipped from one port to another within days days.

The ith package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.

Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within days days.

class Solution:
    def shipWithinDays(self, weights: List[int], days: int) -> int:
        max_cap = sum(weights)
        min_cap = max(weights)

        def days_required(cap):
            days = 1
            i = 0
            sum = 0
            while i < len(weights) - 1:
                sum += weights[i]
                if sum + weights[i + 1] > cap:
                    days += 1
                    sum = 0
                i += 1
            return days

        def find_capacity(upper, lower):
            middle = (upper + lower) // 2
            if upper < lower:
                return lower
            if days_required(middle) > days:
                return find_capacity(upper, middle + 1)
            return find_capacity(middle - 1, lower)
        
        return find_capacity(max_cap, min_cap)

Write an algorithm to determine if a number n is happy.

A happy number is a number defined by the following process:

Starting with any positive integer, replace the number by the sum of the squares of its digits.
Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.
Those numbers for which this process ends in 1 are happy.
Return true if n is a happy number, and false if not.

class Solution:
    def isHappy(self, n: int) -> bool:
        res = 0
        lst = []
        while n != 1:
            for i in range(len(str(n))):
                res += (int(str(n)[i])) ** 2
            print(f"{res=}")
            n = res
            if n in lst:
                return False
            lst.append(n)
            res = 0
        return True

Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        if head is None:
            return None
        lst = []
        while head:
            if head.val != val:
                lst.append(head.val)
            head = head.next
        if len(lst) == 0:
            return None
        res = cur = ListNode(lst[0])
        for i in range(1, len(lst)):
            cur.next = ListNode(lst[i])
            cur = cur.next
        return res

Given an integer num, repeatedly add all its digits until the result has only one digit, and return it.

class Solution:
    def addDigits(self, num: int) -> int:
        while len(str(num)) != 1:
            res = 0
            for i in range(len(str(num))):
                print(f"{i=},{num=}")
                res += int(str(num)[i])
            num = res
        return num

Write a function that reverses a string. The input string is given as an array of characters s.

You must do this by modifying the input array in-place with O(1) extra memory.

class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        s.reverse()

Given an integer n, return true if it is a power of two. Otherwise, return false.

An integer n is a power of two, if there exists an integer x such that n == 2x.

class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        if n == 0:
            return False
        if n == 1:
            return True
        if n % 2 == 0:
            while n % 2 == 0:
                n = n / 2
            if n == 1:
                return True
        return False

Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.

You must implement a solution with a linear runtime complexity and use only constant extra space.

class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        lst = []
        for element in nums:
            if element in lst:
                lst.remove(element)
            else:
                lst.append(element)
        return lst[0]

Given the head of a singly linked list, reverse the list, and return the reversed list.

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head is None:
            return None
        lst = []
        while head:
            lst.append(head.val)
            head = head.next
        lst.reverse()
        print(f"{lst=}")
        res = cur = ListNode(lst[0])
        for i in range(1, len(lst)):
            cur.next = ListNode(lst[i])
            cur = cur.next
        return res

Given an array nums of size n, return the majority element.

The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        dic = {}
        for element in nums:
            if element not in dic.keys():
                dic[element] = 1
            else:
                dic[element] += 1
            if dic[element] > len(nums) // 2:
                return element

A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.

Given a string s, return true if it is a palindrome, or false otherwise.

class Solution:
    def isPalindrome(self, s: str) -> bool:
        if s == " ":
            return True
        cap = ['7','5','6','3','4','9','8','1','2','0','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
        low = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
        s = s.lower()
        i = 0
        while i < len(s):
            if s[i] not in cap and s[i] not in low:
                s = s[:i] + s[i + 1:]
                # print(f"{s=}")
                i -= 1
            i += 1
        new_string = ''
        for i in range(len(s)):
            new_string = s[i] + new_string
        if s == new_string:
            return True
        else:
            return False

Given a callable function f(x, y) with a hidden formula and a value z, reverse engineer the formula and return all positive integer pairs x and y where f(x,y) == z. You may return the pairs in any order.

"""
   This is the custom function interface.
   You should not implement it, or speculate about its implementation
   class CustomFunction:
       # Returns f(x, y) for any given positive integers x and y.
       # Note that f(x, y) is increasing with respect to both x and y.
       # i.e. f(x, y) < f(x + 1, y), f(x, y) < f(x, y + 1)
       def f(self, x, y):
  
"""

class Solution:

    def findSolution(self, customfunction: 'CustomFunction', z: int) -> List[List[int]]:
        y = z
        x = 1
        lst = []
        while x <= z and y >= 1:
            value = customfunction.f(x,y)
            if value < z:
                x += 1
            elif value == z:
                lst.append([x,y])
                x += 1
                y -= 1
            else:
                y -= 1
        return lst

You are climbing a staircase. It takes n steps to reach the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

class Solution:
    def climbStairs(self, n: int) -> int:
        if n <= 3:
            return n
        p1 = 3
        p2 = 2
        cur = 0
        for _ in range(3,n):
            cur = p1 + p2
            p2 = p1
            p1 = cur
        return cur

Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        
        def is_mirror(left, right):
            if left is None and right is None:
                return True
            if left is None or right is None or left.val != right.val:
                return False
            return is_mirror(left.left, right.right) and is_mirror(left.right, right.left)
        
        return is_mirror(root, root)

Given the root of a binary tree, return the inorder traversal of its nodes' values.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        lst = []
        self.helper(root, lst)
        return lst
    
    def helper(self, root, lst):
        if root:
            self.helper(root.left, lst)
            lst.append(root.val)
            self.helper(root.right, lst)

Given the root of a binary tree, return its maximum depth.

A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1

Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        if not nums:
            return None
        mid = len(nums) // 2
        root = TreeNode(nums[mid])
        root.left = self.sortedArrayToBST(nums[:mid])
        root.right = self.sortedArrayToBST(nums[mid + 1:])
        return root

Given a binary tree, determine if it is height-balanced.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        
        def helper(root):
            if not root:
                return [True, 0]
            left_balanced, left_height = helper(root.left)
            right_balanced, right_height = helper(root.right)
            isBalanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1
            return [isBalanced, 1 + max(left_height, right_height)]
        
        return helper(root)[0]

Given an integer numRows, return the first numRows of Pascal's triangle.

class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        if numRows == 0:
            return []
        if numRows == 1:
            return [[1]]
        prev = self.generate(numRows - 1)
        new = [1] * numRows
        for i in range(1, numRows - 1):
            new[i] = prev[-1][i - 1] + prev[-1][i]
        prev.append(new)
        return prev

Given head, the head of a linked list, determine if the linked list has a cycle in it.

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        fast = head
        slow = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
            if slow == fast:
                return True
        return False

You are given an array prices where prices[i] is the price of a given stock on the ith day.

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        buy = prices[0]
        profit = 0

        for i in range(len(prices)):
            if prices[i] < buy:
                buy = prices[i]

            profit = max(profit, prices[i] - buy)

        return profit

Given the roots of two binary trees p and q, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        if p is None and q is None:
            return True
        if p is None or q is None:
            return False
        if p.val == q.val:
            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
        return False

Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if root is None:
            return False
        if root.left is None and root.right is None:
            return targetSum == root.val
        left_sum = self.hasPathSum(root.left, targetSum - root.val)
        right_sum = self.hasPathSum(root.right, targetSum - root.val)
        return left_sum or right_sum

Given a binary tree, find its minimum depth.

The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0
        if root.left is None and root.right is None:
            return 1
        if root.left is None and root.right:
            return self.minDepth(root.right) + 1
        if root.right is None and root.left:
            return self.minDepth(root.left) + 1
        if root.right and root.left:
            return min(self.minDepth(root.left) + 1, self.minDepth(root.right) + 1)

Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle.

class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        ans = [1,1]
        if rowIndex == 0:
            return [1]
        if rowIndex == 1:
            return ans
        prev = self.getRow(rowIndex - 1)
        res = [1] * (rowIndex + 1)
        for i in range(1, rowIndex):
            print(f"{i=}")
            res[i] = prev[i - 1] + prev[i]
        return res

Given two strings s and t, determine if they are isomorphic.

class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        d = {}
        lst = []
        for i in range(len(s)):
            d[s[i]] = t[i]
        for i in range(len(s)):
            if d[s[i]] != t[i]:
                return False
        for i in d.values():
            if i in lst:
                return False
            lst.append(i)
        return True

Given the root of a binary tree, return the postorder traversal of its nodes' values.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans = []
        def helper(root):
            if root is None:
                return ans
            helper(root.left)
            helper(root.right)
            ans.append(root.val)
            return ans
        return helper(root)

Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.

class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        nums = sorted(nums)
        for i in range(1, len(nums)):
            if nums[i] == nums[i - 1]:
                return True
        return False

Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.

class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
        set1 = set()
        for i in range(len(nums)):
            if nums[i] in set1:
                return True
            set1.add(nums[i])
            if len(set1) > k:
                set1.remove(nums[i - k])

        return False

Given the root of a binary tree, invert the tree, and return its root.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        a = root
        self.invert(a)
        return root
    def invert(self, a):
        if a is None:
            return 
        a.left, a.right = a.right, a.left
        self.invert(a.left)
        self.invert(a.right)

You are given a sorted unique integer array nums.

A range [a,b] is the set of all integers from a to b (inclusive).

Return the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.

class Solution:
    def summaryRanges(self, nums: List[int]) -> List[str]:
        ans = []
        if not nums:
            return ans
        first = nums[0]
        for i in range(1, len(nums) + 1):
            if i == len(nums) or nums[i] != nums[i - 1] + 1:
                if first == nums[i - 1]:
                    ans.append(str(first))
                else:
                    ans.append(f"{first}->{nums[i - 1]}")
                if i < len(nums):
                    first = nums[i]
        return ans

Given the head of a singly linked list, return true if it is a palindrome or false otherwise.

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:
        string = ''
        while head:
            string = string + str(head.val)
            head = head.next
        if string == string[::-1]:
            return True
        return False

Given the root of a binary tree, return all root-to-leaf paths in any order.

A leaf is a node with no children.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        def helper(node, path):
            if not node.right and not node.left:
                paths.append(path + str(node.val))
                return
            if node.right:
                helper(node.right, path + str(node.val) + '->')
            if node.left:
                helper(node.left, path + str(node.val) + '->')
        paths = []
        if root:
            helper(root, '')
        return paths

Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.

Note that you must do this in-place without making a copy of the array.

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        for i in range(len(nums)):
            if nums[i] == 0:
                nums.remove(0)
                nums.append(0)

Given a pattern and a string s, find if s follows the same pattern.

Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s. Specifically:

Each letter in pattern maps to exactly one unique word in s.
Each unique word in s maps to exactly one letter in pattern.
No two letters map to the same word, and no two words map to the same letter.

class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        if pattern == s and len(pattern) == len(s) and len(pattern) > 1:
            return False
        word = []
        d = {}
        lst = []
        j = 0
        s += ' '
        for i in range(len(s)):
            if s[i] == ' ':
                word.append(s[j:i])
                j = i + 1
        print(word)
        if len(pattern) > len(word):
            return False
        for i in range(len(pattern)):
            d[pattern[i]] = word[i]
        print(d)
        print(d.keys())
        for i in d.keys():
            if len(d.keys()) == 1 and len(d.values()) == 1 and len(word) != 1:
                return False
            if d[i] in lst:
                if len(word) >= len(d.keys()):
                    return False
            lst.append(d[i])
        for i in range(len(pattern)):
            print(i)
            print(d[pattern[i]])
            if d[pattern[i]] != word[i]:
                return False
        return True

Given an integer n, return true if it is a power of three. Otherwise, return false.

An integer n is a power of three, if there exists an integer x such that n == 3x.

class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        if n <= 0:
            return False
        while n % 3 == 0:
            n = n // 3
        if n == 1:
            return True
        return False

You are playing the following Nim Game with your friend:

Initially, there is a heap of stones on the table.
You and your friend will alternate taking turns, and you go first.
On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.
The one who removes the last stone is the winner.
Given n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false.

class Solution:
    def canWinNim(self, n: int) -> bool:
        while n > 4:
            n = n % 4
        if n == 1 or n == 2 or n == 3:
            return True
        else:
            return False

Given an integer n, return true if it is a power of four. Otherwise, return false.

An integer n is a power of four, if there exists an integer x such that n == 4x.

class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        if n <= 0:
            return False
        if n == 1:
            return True
        while n >= 4:
            n = n / 4
        return n == 1

Given a string s, reverse only all the vowels in the string and return it.

The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.

class Solution:
    def reverseVowels(self, s: str) -> str:
        vowels = ['a','e','i','o','u','A','E','I','O','U']
        lst = []
        for i in range(len(s)):
            if s[i] in vowels:
                lst.append(s[i])
        lst = lst[::-1]
        for i in range(len(s)):
            if s[i] in vowels:
                s = s[:i] + lst[0] + s[i + 1:]
                lst.pop(0)
        return s

Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.

class Solution:
    def firstUniqChar(self, s: str) -> int:
        string = ''
        for i in range(len(s)):
            if s[i] not in s[i + 1:] and s[i] not in string:
                return i
            string += s[i]
        return -1

You are given two strings s and t.

String t is generated by random shuffling string s and then add one more letter at a random position.

Return the letter that was added to t.

class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        s = ''.join(sorted(s))
        t = ''.join(sorted(t))
        print(s)
        print(t)
        for i in range(len(s)):
            if s[i] != t[i]:
                if s[i] in t[i:]:
                    return t[i]
        return t[-1]

Given an integer n, return a string array answer (1-indexed) where:

answer[i] == "FizzBuzz" if i is divisible by 3 and 5.
answer[i] == "Fizz" if i is divisible by 3.
answer[i] == "Buzz" if i is divisible by 5.
answer[i] == i (as a string) if none of the above conditions are true.

class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        lst = []
        i = 1
        while i <= n:
            lst.append(str(i))
            i += 1
        for i in range(len(lst)):
            if int(lst[i]) % 3 == 0 and int(lst[i]) % 5 == 0:
                lst[i] = 'FizzBuzz'
            elif int(lst[i]) % 5 == 0:
                lst[i] = 'Buzz'
            elif int(lst[i]) % 3 == 0:
                lst[i] = 'Fizz'
        return lst

Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.

class Solution:
    def thirdMax(self, nums: List[int]) -> int:
        lst = []
        nums = sorted(nums)
        count = 0
        nums = nums[::-1]
        if len(nums) <= 2:
            return nums[0]
        for i in range(len(nums)):
            if nums[i] not in lst:
                count += 1
                lst.append(nums[i])
            if count == 3:
                return nums[i]
        if count < 3:
            return nums[0]

Given a binary array nums, return the maximum number of consecutive 1's in the array.

class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        lst = []
        count = 0
        for i in range(len(nums)):
            if nums[i] == 1:
                count += 1
            if nums[i] == 0:
                lst.append(count)
                count = 0
            if i == len(nums) - 1:
                lst.append(count)
        return max(lst)

The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,

F(0) = 0, F(1) = 1
F(n) = F(n - 1) + F(n - 2), for n > 1.
Given n, calculate F(n).

class Solution:
    def fib(self, n: int) -> int:
        if n == 0:
            return 0
        if n == 1:
            return 1
        return self.fib(n - 1) + self.fib(n - 2)

A web developer needs to know how to design a web page's size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:

The area of the rectangular web page you designed must equal to the given target area.
The width W should not be larger than the length L, which means L >= W.
The difference between length L and width W should be as small as possible.
Return an array [L, W] where L and W are the length and width of the web page you designed in sequence.

class Solution:
    def constructRectangle(self, area: int) -> List[int]:
        if area == 1:
            return [1,1]
        lst = []
        for i in range(1, area):
            if area // i * i == area:
                lst.append([area // i, i])
        return lst[len(lst) // 2]

A binary watch has 4 LEDs on the top to represent the hours (0-11), and 6 LEDs on the bottom to represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.

class Solution:
    def readBinaryWatch(self, turnedOn: int) -> List[str]:
        ans = []
        for h in range(12):
            for m in range(60):
                hOnes = bin(h).count('1')
                mOnes = bin(m).count('1')
                if hOnes + mOnes == turnedOn:
                    ans.append(f'{h}:{m:02d}')
        return ans

You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.

class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -> int:
        ans = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    ans += 4
                    if i > 0 and grid[i - 1][j] == 1:
                        ans -= 2
                    if j > 0 and grid[i][j - 1] == 1:
                        ans -= 2
        return ans

Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.

class Solution:
    def longestPalindrome(self, s: str) -> int:
        ans = 0
        character_set = set()
        for char in s:
            if char in character_set:
                character_set.remove(char)
                ans += 2
            else:
                character_set.add(char)
        if character_set:
            ans += 1
        return ans

Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.

class Solution:
    def countBits(self, n: int) -> List[int]:
        ans = [0] * (n + 1)
        for i in range(1, n + 1):
            ans[i] = ans[i // 2] + (i & 1)
        return ans

Given a string s, return the string after replacing every uppercase letter with the same lowercase letter.

class Solution:
    def toLowerCase(self, s: str) -> str:
        return s.lower()

The Hamming distance between two integers is the number of positions at which the corresponding bits are different.

Given two integers x and y, return the Hamming distance between them.

class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        xor = x ^ y
        return bin(x ^ y).count('1')

Given an integer num, return a string of its base 7 representation.

class Solution:
    def convertToBase7(self, num: int) -> str:
        if num == 0:
            return '0'
        sign = '-' if num < 0 else ''
        num = abs(num)
        digits = []
        while num:
            digits.append(str(num % 7))
            num = num // 7
        return sign + ''.join((reversed(digits)))

Reverse bits of a given 32 bits unsigned integer.

class Solution:
    def reverseBits(self, n: int) -> int:
        result = 0
        for _ in range(32):
            bit = n & 1
            result = (result << 1) | bit
            n >>= 1
        return result

Given a positive integer n, write a function that returns the number of set bits in its binary representation (also known as the Hamming weight).

class Solution:
    def hammingWeight(self, n: int) -> int:
        return bin(n).count('1')

The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.

For example, The integer 5 is "101" in binary and its complement is "010" which is the integer 2.
Given an integer num, return its complement.

class Solution:
    def findComplement(self, num: int) -> int:
        numbits = num.bit_length()
        mask = (1 << numbits) - 1
        return num ^ mask

Given a n-ary tree, find its maximum depth.

"""
# Definition for a Node.
class Node:
    def __init__(self, val: Optional[int] = None, children: Optional[List['Node']] = None):
        self.val = val
        self.children = children
"""

class Solution:
    def maxDepth(self, root: 'Node') -> int:
        if root is None:
            return 0
        maxdepth = 0
        for child in root.children:
            maxdepth = max(self.maxDepth(child), maxdepth)
        return maxdepth + 1

Given an integer array nums of 2n integers, group these integers into n pairs (a1, b1), (a2, b2), ..., (an, bn) such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum.

class Solution:
    def arrayPairSum(self, nums: List[int]) -> int:
        nums = sorted(nums)
        sum = 0
        lst = []
        for i in range(0, len(nums), 2):
            lst.append([nums[i],nums[i + 1]])
        for element in lst:
            sum += min(element)
        return sum

You are given two binary trees root1 and root2.

Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.

Return the merged tree.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root1:
            return root2
        if not root2:
            return root1
        root1.val += root2.val
        root1.left = self.mergeTrees(root1.left, root2.left)
        root1.right = self.mergeTrees(root1.right, root2.right)
        return root1

Given the root of an n-ary tree, return the preorder traversal of its nodes' values.

Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)

"""
# Definition for a Node.
class Node:
    def __init__(self, val: Optional[int] = None, children: Optional[List['Node']] = None):
        self.val = val
        self.children = children
"""

class Solution:
    def preorder(self, root: 'Node') -> List[int]:
        ans = []
        self.traverse(root, ans)
        return ans
    def traverse(self, node, ans):
        if not node:
            return
        ans.append(node.val)
        for child in node.children:
            self.traverse(child, ans)

Given the root of a binary tree, return the length of the diameter of the tree.

The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.

The length of a path between two nodes is represented by the number of edges between them.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        def diameter(node, res):
            if not node:
                return 0
            left = diameter(node.left, res)
            right = diameter(node.right, res)
            res[0] = max(res[0], left + right)
            return max(left , right) + 1
        res = [0]
        diameter(root,res)
        return res[0]

Given the root of an n-ary tree, return the postorder traversal of its nodes' values.

Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)

"""
# Definition for a Node.
class Node:
    def __init__(self, val: Optional[int] = None, children: Optional[List['Node']] = None):
        self.val = val
        self.children = children
"""

class Solution:
    def postorder(self, root: 'Node') -> List[int]:
        if root is None:
            return []
        res = []
        def dfs(root):
            for x in root.children:
                dfs(x)
            res.append(root.val)
        dfs(root)
        return res

Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.

class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        n = bin(n)
        s = str(n)
        for i in range(len(s)):
            if i == len(s) - 1:
                return True
            if s[i] != s[i + 1]:
                continue
            else:
                return False
        return True

We have two special characters:

The first character can be represented by one bit 0.
The second character can be represented by two bits (10 or 11).
Given a binary array bits that ends with 0, return true if the last character must be a one-bit character.

class Solution:
    def isOneBitCharacter(self, bits: List[int]) -> bool:
        if bits == [0]:
            return True
        while bits:
            if len(bits) > 1:
                if [bits[0], bits[1]] == [1,0]:
                    bits.pop(0)
                    bits.pop(0)
            if bits == [1]:
                return False
            if bits == [0]:
                return True
            if len(bits) > 1:
                if [bits[0], bits[1]] == [1,1]:
                    bits.pop(0)
                    bits.pop(0)
            if bits == []:
                return False
            if bits[0] == 0:
                bits.pop(0)
        return True

Given an m x n matrix, return true if the matrix is Toeplitz. Otherwise, return false.

A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same elements.

class Solution:
    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:
        row = len(matrix)
        column = len(matrix[0])
        row1 = matrix[0]
        for i in range(1, row):
            mat = matrix[i]
            for j in range(1, column):
                if row1[j - 1] != mat[j]:
                    return False
            row1 = mat
        return True

You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels.

Letters are case sensitive, so "a" is considered a different type of stone from "A".

class Solution:
    def numJewelsInStones(self, jewels: str, stones: str) -> int:
        lst = []
        count = 0
        for i in range(len(jewels)):
            lst.append(jewels[i])
        for i in range(len(stones)):
            if stones[i] in lst:
                count += 1
        return count

Given a 2D integer array matrix, return the transpose of matrix.

The transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.

class Solution:
    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:
        return list(map(list, zip(*matrix)))

Given an array of points on the X-Y plane points where points[i] = [xi, yi], return the area of the largest triangle that can be formed by any three different points. Answers within 10-5 of the actual answer will be accepted.

class Solution:
    def largestTriangleArea(self, points: List[List[int]]) -> float:
        area = 0
        length = len(points)
        for i in range(0, length):
            x1, y1 = points[i]
            for j in range(i + 1, length):
                x2, y2 = points[j]
                for q in range(j + 1, length):
                    x3, y3 = points[q]
                    curr = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))
                    if curr > area:
                        area = curr
        return area

Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.

To flip an image horizontally means that each row of the image is reversed.

For example, flipping [1,1,0] horizontally results in [0,1,1].
To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.

For example, inverting [0,1,1] results in [1,0,0].

class Solution:
    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:
        lst1 = []
        lst2 = []
        for element in image:
            element = element[::-1]
            for element1 in element:
                if element1 == 0:
                    element1 = 1
                else:
                    element1 = 0
                lst2.append(element1)
        while lst2:
            lst1.append(lst2[0:len(image[0])])
            lst2 = lst2[len(image[0]):]
        return lst1

Given head which is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number.

Return the decimal value of the number in the linked list.

The most significant bit is at the head of the linked list.

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def getDecimalValue(self, head: Optional[ListNode]) -> int:
        s = ''
        while head:
            s += str(head.val)
            head = head.next
        return int(s, 2)

A binary tree is uni-valued if every node in the tree has the same value.

Given the root of a binary tree, return true if the given tree is uni-valued, or false otherwise.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isUnivalTree(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        if root.left and root.right:
            if root.val == root.left.val and root.val == root.right.val:
                return self.isUnivalTree(root.left) and self.isUnivalTree(root.right)
            else:
                return False
        elif root.left and not root.right:
            if root.val == root.left.val:
                return self.isUnivalTree(root.left)
            else:
                return False
        elif not root.left and not root.right:
            return True
        else:
            if root.val == root.right.val:
                return self.isUnivalTree(root.right)
            else:
                return False

Given a square matrix mat, return the sum of the matrix diagonals.

Only include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal.

class Solution:
    def diagonalSum(self, mat: List[List[int]]) -> int:
        sum = 0
        for i in range(len(mat)):
            sum += mat[i][i]
        for i in range(len(mat)):
            sum += mat[len(mat) - 1 - i][i]
        if len(mat) % 2 != 0:
            sum -= mat[len(mat) // 2][len(mat) // 2]
        return sum

Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.

class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        count = 0
        for element in grid:
            for i in range(len(element)):
                if element[i] < 0:
                    count += 1
        return count

The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.

For example, The integer 5 is "101" in binary and its complement is "010" which is the integer 2.
Given an integer n, return its complement.

class Solution:
    def bitwiseComplement(self, n: int) -> int:
        binary = bin(n)[2:]
        for i in range(len(binary)):
            if binary[i] == '0':
                binary = binary[:i] + '1' + binary[i + 1:]
            else:
                binary = binary[:i] + '0' + binary[i + 1:]
        return int(binary, 2)

You are given a binary array nums (0-indexed).

We define xi as the number whose binary representation is the subarray nums[0..i] (from most-significant-bit to least-significant-bit).

For example, if nums = [1,0,1], then x0 = 1, x1 = 2, and x2 = 5.
Return an array of booleans answer where answer[i] is true if xi is divisible by 5.

class Solution:
    def prefixesDivBy5(self, nums: List[int]) -> List[bool]:
        s = ''
        lst = []
        for i in range(len(nums)):
            s = s + str(nums[i])
            lst.append(int(s, 2) % 5 == 0)
        return lst

Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a leaf value sequence.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:
        def findSequence(root, res):
            if not root:
                return
            if not root.left and not root.right:
                res.append(root.val)
            findSequence(root.left, res)
            findSequence(root.right, res)
        root1seq = []
        root2seq = []
        findSequence(root1, root1seq)
        findSequence(root2, root2seq)
        return root1seq == root2seq

Given an m x n matrix of distinct numbers, return all lucky numbers in the matrix in any order.

A lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column.

class Solution:
    def luckyNumbers(self, matrix: List[List[int]]) -> List[int]:
        lst = []
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if matrix[i][j] == min(matrix[i]) and matrix[i][j] == max(matrix[z][j] for z in range(len(matrix))):
                    lst.append(matrix[i][j])
        return lst

You are given an integer n and an integer start.

Define an array nums where nums[i] = start + 2 * i (0-indexed) and n == nums.length.

Return the bitwise XOR of all elements of nums.

class Solution:
    def xorOperation(self, n: int, start: int) -> int:
        lst = []
        i = 0
        ans = 0
        while n != 0:
            n -= 1
            lst.append(start + 2 * i)
            i += 1
        for i in range(len(lst)):
            ans = ans ^ lst[i]
        return ans

Given a binary string s ​​​​​without leading zeros, return true​​​ if s contains at most one contiguous segment of ones. Otherwise, return false.

class Solution:
    def checkOnesSegment(self, s: str) -> bool:
        if '0' not in s:
            return True
        while s[0] == '1':
            s = s[1:]
        if '1' in s:
            return False
        else:
            return True

You are given the root of a binary tree where each node has a value 0 or 1. Each root-to-leaf path represents a binary number starting with the most significant bit.

For example, if the path is 0 -> 1 -> 1 -> 0 -> 1, then this could represent 01101 in binary, which is 13.
For all leaves in the tree, consider the numbers represented by the path from the root to that leaf. Return the sum of these numbers.

The test cases are generated so that the answer fits in a 32-bits integer.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:
        def dfs(node, path):
            if not node:
                return 0
            path = (path << 1) + node.val
            if not node.left and not node.right:
                return path
            return dfs(node.left, path) + dfs(node.right, path)
        return dfs(root, 0)

There is a hidden integer array arr that consists of n non-negative integers.

It was encoded into another integer array encoded of length n - 1, such that encoded[i] = arr[i] XOR arr[i + 1]. For example, if arr = [1,0,2,1], then encoded = [1,2,3].

You are given the encoded array. You are also given an integer first, that is the first element of arr, i.e. arr[0].

Return the original array arr. It can be proved that the answer exists and is unique.

class Solution:
    def decode(self, encoded: List[int], first: int) -> List[int]:
        lst = [first]
        for i in range(len(encoded)):
            lst.append(first ^ encoded[i])
            first = first ^ encoded[i]
        return lst

Given an integer n (in base 10) and a base k, return the sum of the digits of n after converting n from base 10 to base k.

After converting, each digit should be interpreted as a base 10 number, and the sum should be returned in base 10.

class Solution:
    def sumBase(self, n: int, k: int) -> int:
        string = ''
        res = 0
        while n != 0:
            string += str(n % k)
            n = n // k
        for i in range(len(string)):
            res += int(string[i])
        return res

You are given a string s consisting only of the characters '0' and '1'. In one operation, you can change any '0' to '1' or vice versa.

The string is called alternating if no two adjacent characters are equal. For example, the string "010" is alternating, while the string "0100" is not.

Return the minimum number of operations needed to make s alternating.

class Solution:
    def minOperations(self, s: str) -> int:
        count1 = 0
        count2 = 0
        ans1 = '01'
        ans2 = '10'
        if len(s) % 2 == 0:
            bin_str1 = ans1 * int(len(s) / 2)
        else:
            bin_str1 = ans1 * int(len(s) / 2) + '0'
        if len(s) % 2 == 0:
            bin_str2 = ans2 * int(len(s) / 2)
        else:
            bin_str2 = ans2 * int(len(s) / 2) + '1'
        for i in range(len(s)):
            if s[i] != bin_str1[i]:
                count1 += 1
            if s[i] != bin_str2[i]:
                count2 += 1
        return min(count1, count2)

Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:
        res = []
        def findaverage(node, level):
            if not node:
                return
            if level > len(res):
                res.append([node.val, 1])
            else:
                res[level - 1][0] += node.val
                res[level - 1][1] += 1
            findaverage(node.left, level + 1)
            findaverage(node.right, level + 1)
        findaverage(root, 1)
        return [i[0] / i[1] for i in res]

Given the array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn].

Return the array in the form [x1,y1,x2,y2,...,xn,yn].

class Solution:
    def shuffle(self, nums: List[int], n: int) -> List[int]:
        s = 0
        lst = []
        while s != n:
            lst += [nums[s], nums[s + n]]
            s += 1
        return lst

Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1.

Sort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2. Elements that do not appear in arr2 should be placed at the end of arr1 in ascending order.

class Solution:
    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:
        lst = []
        for i in range(len(arr2)):
            while arr2[i] in arr1:
                arr1.remove(arr2[i])
                lst.append(arr2[i])
        arr1 = sorted(arr1)
        for i in range(len(arr1)):
            if arr1[i] not in arr2:
                lst.append(arr1[i])
        return lst

Given a date, return the corresponding day of the week for that date.

The input is given as three integers representing the day, month and year respectively.

Return the answer as one of the following values {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}.

class Solution:
    def dayOfTheWeek(self, day: int, month: int, year: int) -> str:
        return date(year, month, day).strftime('%A')

Given an array of integers arr, replace each element with its rank.

The rank represents how large the element is. The rank has the following rules:

Rank is an integer starting from 1.
The larger the element, the larger the rank. If two elements are equal, their rank must be the same.
Rank should be as small as possible.

class Solution:
    def arrayRankTransform(self, arr: List[int]) -> List[int]:
        my_list = sorted(set(arr))
        rank = {value : rank + 1 for rank, value in enumerate(my_list)}
        for i in range(len(arr)):
            arr[i] = rank[arr[i]]
        return arr

Given two binary strings a and b, return their sum as a binary string.

class Solution:
    def addBinary(self, a: str, b: str) -> str:
        return bin(int(a, 2) + int(b, 2))[2:]

Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        if not nums:
            return None
        mid = len(nums) // 2
        return TreeNode(nums[mid], self.sortedArrayToBST(nums[:mid]), self.sortedArrayToBST(nums[mid + 1:]))

You are given the root of a binary search tree (BST) and an integer val.

Find the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if not root:
            return None
        if val > root.val:
            return self.searchBST(root.right, val)
        if val < root.val:
            return self.searchBST(root.left, val)
        if val == root.val:
            return root

Given a 32-bit integer num, return a string representing its hexadecimal representation. For negative integers, two’s complement method is used.

All the letters in the answer string should be lowercase characters, and there should not be any leading zeros in the answer except for the zero itself.

Note: You are not allowed to use any built-in library method to directly solve this problem.

class Solution:
    def toHex(self, num: int) -> str:
        return "{0:x}".format(num) if num >= 0 else "{0:x}".format(num + 2 ** 32)

Given a valid (IPv4) IP address, return a defanged version of that IP address.

A defanged IP address replaces every period "." with "[.]".

class Solution:
    def defangIPaddr(self, address: str) -> str:
        return address.replace('.', '[.]')

Given the root of a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def increasingBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        lst = []
        def helper(node):
            if not node:
                return
            lst.append(node.val)
            helper(node.left)
            helper(node.right)
        helper(root)
        lst = sorted(lst)
        ans = TreeNode(lst[0])
        res = ans
        while len(lst) > 1:
            ans.right = TreeNode(lst[1])
            ans = ans.right
            lst.pop(1)
        return res

Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.

Return any array that satisfies this condition.

class Solution:
    def sortArrayByParity(self, nums: List[int]) -> List[int]:
        res = []
        for i in range(len(nums)):
            if nums[i] % 2 == 0:
                res = [nums[i]] + res
            else:
                res = res + [nums[i]]
        return res

Given an array of integers nums, half of the integers in nums are odd, and the other half are even.

Sort the array so that whenever nums[i] is odd, i is odd, and whenever nums[i] is even, i is even.

Return any answer array that satisfies this condition.

class Solution:
    def sortArrayByParityII(self, nums: List[int]) -> List[int]:
        lst1 = []
        lst2 = []
        lst = []
        for i in range(len(nums)):
            if nums[i] % 2 == 0:
                lst1.append(nums[i])
            else:
                lst2.append(nums[i])
        while lst1 and lst2:
            lst.append(lst1[0])
            lst.append(lst2[0])
            lst1.pop(0)
            lst2.pop(0)
        return lst

Given an array of distinct integers arr, find all pairs of elements with the minimum absolute difference of any two elements.

Return a list of pairs in ascending order(with respect to pairs), each pair [a, b] follows

a, b are from arr
a < b
b - a equals to the minimum absolute difference of any two elements in arr

class Solution:
    def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:
        arr = sorted(arr)
        lst = []
        ans = []
        for i in range(len(arr)):
            if i == len(arr) - 1:
                break
            lst.append(arr[i + 1] - arr[i])
        minimum = min(lst)
        for i in range(len(lst)):
            if lst[i] == minimum:
                ans.append([arr[i], arr[i + 1]])
        return ans

Balanced strings are those that have an equal quantity of 'L' and 'R' characters.

Given a balanced string s, split it into some number of substrings such that:

Each substring is balanced.
Return the maximum number of balanced strings you can obtain.

class Solution:
    def balancedStringSplit(self, s: str) -> int:
        rcount = 0
        lcount = 0
        ans = 0
        for i in range(len(s)):
            if s[i] == 'R':
                rcount += 1
            if s[i] == 'L':
                lcount += 1
            if rcount == lcount:
                rcount = 0
                lcount = 0
                ans += 1
        return ans

Given two binary trees original and cloned and given a reference to a node target in the original tree.

The cloned tree is a copy of the original tree.

Return a reference to the same node in the cloned tree.

Note that you are not allowed to change any of the two trees or the target node and the answer must be a reference to a node in the cloned tree.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:
        if not original:
            return 
        elif original == target:
            return cloned
        else:
            return self.getTargetCopy(original.left, cloned.left, target) or self.getTargetCopy(original.right, cloned.right, target)

We are given a list nums of integers representing a list compressed with run-length encoding.

Consider each adjacent pair of elements [freq, val] = [nums[2*i], nums[2*i+1]] (with i >= 0).  For each such pair, there are freq elements with value val concatenated in a sublist. Concatenate all the sublists from left to right to generate the decompressed list.

Return the decompressed list.

class Solution:
    def decompressRLElist(self, nums: List[int]) -> List[int]:
        lst = []
        for i in range(len(nums) // 2):
            lst += [nums[2 * i + 1]] * nums[2 * i]
        return lst

You are given a string s formed by digits and '#'. We want to map s to English lowercase characters as follows:

Characters ('a' to 'i') are represented by ('1' to '9') respectively.
Characters ('j' to 'z') are represented by ('10#' to '26#') respectively.
Return the string formed after mapping.

The test cases are generated so that a unique mapping will always exist.

class Solution:
    def freqAlphabets(self, s: str) -> str:
        lst = []
        res = ''
        while len(s) >= 3:
            if s[2] == '#':
                lst.append(s[:3])
                s = s[3:]
            else:
                lst.append(s[0])
                s = s[1:]
        while s:
            lst.append(s[0])
            s = s[1:]
        d = {'1': 'a', '2': 'b', '3':'c', '4':'d', '5':'e', '6':'f', '7':'g', '8':'h', '9':'i','10#':'j', '11#':'k', '12#':'l', '13#':'m', '14#':'n', '15#':'o','16#':'p','17#':'q','18#':'r','19#':'s','20#':'t','21#':'u','22#':'v','23#':'w','24#':'x','25#':'y','26#':'z'}
        for element in lst:
            res += d[element]
        return res

Given two integer arrays arr1 and arr2, and the integer d, return the distance value between the two arrays.

The distance value is defined as the number of elements arr1[i] such that there is not any element arr2[j] where |arr1[i]-arr2[j]| <= d.

class Solution:
    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:
        count = 0
        for i in range(len(arr1)):
            for j in range(len(arr2)):
                if abs(arr1[i] - arr2[j]) <= d:
                    break
                if abs(arr1[i] - arr2[j]) > d:
                    if j == len(arr2) - 1:
                        count += 1
        return count

Given two arrays of integers nums and index. Your task is to create target array under the following rules:

Initially target array is empty.
From left to right read nums[i] and index[i], insert at index index[i] the value nums[i] in target array.
Repeat the previous step until there are no elements to read in nums and index.
Return the target array.

It is guaranteed that the insertion operations will be valid.

class Solution:
    def createTargetArray(self, nums: List[int], index: List[int]) -> List[int]:
        arr = []
        for i in range(len(index)):
            arr.insert(index[i], nums[i])
        return arr

Given an integer array sorted in non-decreasing order, there is exactly one integer in the array that occurs more than 25% of the time, return that integer.

class Solution:
    def findSpecialInteger(self, arr: List[int]) -> int:
        freq = len(arr) // 4
        d = {}
        for i in range(len(arr)):
            if arr[i] not in d.keys():
                d[arr[i]] = 1
            else:
                d[arr[i]] += 1
            if d[arr[i]] > freq:
                return arr[i]

Given an array nums of integers, return how many of them contain an even number of digits.

class Solution:
    def findNumbers(self, nums: List[int]) -> int:
        count = 0
        for element in nums:
            if len(str(element)) % 2 == 0:
                count += 1
        return count

Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's such that j != i and nums[j] < nums[i].

Return the answer in an array.

class Solution:
    def findNumbers(self, nums: List[int]) -> int:
        count = 0
        for element in nums:
            if len(str(element)) % 2 == 0:
                count += 1
        return count

Given an array of integers arr, a lucky integer is an integer that has a frequency in the array equal to its value.

Return the largest lucky integer in the array. If there is no lucky integer return -1.

class Solution:
    def findLucky(self, arr: List[int]) -> int:
        lst = []
        d = {}
        for i in range(len(arr)):
            if arr[i] in d.keys():
                d[arr[i]] += 1
            else:
                d[arr[i]] = 1
        for i in d.keys():
            if d[i] == i:
                lst.append(i)
        if lst == []:
            return -1
        return max(lst)

Given an integer number n, return the difference between the product of its digits and the sum of its digits.

class Solution:
    def subtractProductAndSum(self, n: int) -> int:
        product = 1
        res = 0
        str_n = str(n)
        for i in range(len(str_n)):
            product = product * int(str_n[i])
            res = res + int(str_n[i])
        return product - res

Given an array of string words, return all strings in words that are a substring of another word. You can return the answer in any order.

class Solution:
    def stringMatching(self, words: List[str]) -> List[str]:
        lst = []
        for i in range(len(words)):
            for element in words:
                if words[i] != element and words[i] in element:
                    if words[i] not in lst:
                        lst.append(words[i])
        return lst

Given an integer num, return the number of steps to reduce it to zero.

In one step, if the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.

class Solution:
    def numberOfSteps(self, num: int) -> int:
        res = 0
        while num != 0:
            if num % 2 == 0:
                num = num / 2
                res += 1
            else:
                num = num - 1
                res += 1
        return res

Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]).

Return the running sum of nums.

class Solution:
    def runningSum(self, nums: List[int]) -> List[int]:
        lst = []
        res = 0
        for i in range(len(nums)):
            res += nums[i]
            lst.append(res)
        return lst

There are n kids with candies. You are given an integer array candies, where each candies[i] represents the number of candies the ith kid has, and an integer extraCandies, denoting the number of extra candies that you have.

Return a boolean array result of length n, where result[i] is true if, after giving the ith kid all the extraCandies, they will have the greatest number of candies among all the kids, or false otherwise.

Note that multiple kids can have the greatest number of candies.

class Solution:
    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:
        lst = []
        for element in candies:
            newcandies = candies.copy()
            newcandies.remove(element)
            print(newcandies)
            if extraCandies + element >= max(newcandies):
                lst.append(True)
            else:
                lst.append(False)
        return lst

Given the array of integers nums, you will choose two different indices i and j of that array. Return the maximum value of (nums[i]-1)*(nums[j]-1).

class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        lst = []
        for i in range(len(nums)):
            for j in range(len(nums)):
                if i != j:
                    lst.append((nums[i] - 1) * (nums[j] - 1))
        return max(lst)

You are given the array paths, where paths[i] = [cityAi, cityBi] means there exists a direct path going from cityAi to cityBi. Return the destination city, that is, the city without any path outgoing to another city.

It is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.

class Solution:
    def destCity(self, paths: List[List[str]]) -> str:
        lst1 = []
        lst2 = []
        for element in paths:
            if element[0] not in lst2:
                lst2.append(element[0])
            for i in range(len(element)):
                if element[i] not in lst1:
                    lst1.append(element[i])
        print(lst1)
        print(lst2)
        for element in lst1:
            if element not in lst2:
                return element

A sequence of numbers is called an arithmetic progression if the difference between any two consecutive elements is the same.

Given an array of numbers arr, return true if the array can be rearranged to form an arithmetic progression. Otherwise, return false.

class Solution:
    def canMakeArithmeticProgression(self, arr: List[int]) -> bool:
        arr = sorted(arr)
        diff = arr[1] - arr[0]
        while len(arr) >= 2:
            if arr[1] - arr[0] != diff:
                return False
            arr.pop(0)
        return True 

You are given an integer n.

We need to group the numbers from 1 to n according to the sum of its digits. For example, the numbers 14 and 5 belong to the same group, whereas 13 and 3 belong to different groups.

Return the number of groups that have the largest size, i.e. the maximum number of elements.

class Solution:
    def countLargestGroup(self, n: int) -> int:
        d = {}
        s = 0 
        count = 0
        for i in range(1, n + 1):
            for j in range(len(str(i))):
                s += int(str(i)[j])
            print(s)
            if s not in d.keys():
                d[s] = 1
            else:
                d[s] += 1
            s = 0
        for q in list(d.keys()):
            if d[q] == max(list(d.values())):
                count += 1
        return count

Given an array of integers arr, and three integers a, b and c. You need to find the number of good triplets.

A triplet (arr[i], arr[j], arr[k]) is good if the following conditions are true:

0 <= i < j < k < arr.length
|arr[i] - arr[j]| <= a
|arr[j] - arr[k]| <= b
|arr[i] - arr[k]| <= c
Where |x| denotes the absolute value of x.

Return the number of good triplets.

class Solution:
    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:
        count = 0
        for i in range(len(arr)):
            for j in range(i + 1, len(arr)):
                for k in range(j + 1, len(arr)):
                    if abs(arr[i] - arr[j]) <= a:
                        if abs(arr[j] - arr[k]) <= b:
                            if abs(arr[i] - arr[k]) <= c:
                                count += 1
        return count

Design a parking system for a parking lot. The parking lot has three kinds of parking spaces: big, medium, and small, with a fixed number of slots for each size.

Implement the ParkingSystem class:

ParkingSystem(int big, int medium, int small) Initializes object of the ParkingSystem class. The number of slots for each parking space are given as part of the constructor.
bool addCar(int carType) Checks whether there is a parking space of carType for the car that wants to get into the parking lot. carType can be of three kinds: big, medium, or small, which are represented by 1, 2, and 3 respectively. A car can only park in a parking space of its carType. If there is no space available, return false, else park the car in that size space and return true.

class ParkingSystem:

    def __init__(self, big: int, medium: int, small: int):
        self.big = big
        self.medium = medium
        self.small = small

    def addCar(self, carType: int) -> bool:
        if carType == 1:
            if self.big >= 1:
                self.big -= 1
                return True
            else:
                return False
        elif carType == 2:
            if self.medium >= 1:
                self.medium -= 1
                return True
            else:
                return False
        else:
            if self.small >= 1:
                self.small -= 1
                return True
            else:
                return False


# Your ParkingSystem object will be instantiated and called as such:
# obj = ParkingSystem(big, medium, small)
# param_1 = obj.addCar(carType)

Given an array of integers nums, return the number of good pairs.

A pair (i, j) is called good if nums[i] == nums[j] and i < j.

class Solution:
    def numIdenticalPairs(self, nums: List[int]) -> int:
        count = 0
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                if nums[i] == nums[j]:
                    count += 1
        return count

You have a bomb to defuse, and your time is running out! Your informer will provide you with a circular array code of length of n and a key k.

To decrypt the code, you must replace every number. All the numbers are replaced simultaneously.

If k > 0, replace the ith number with the sum of the next k numbers.
If k < 0, replace the ith number with the sum of the previous k numbers.
If k == 0, replace the ith number with 0.
As code is circular, the next element of code[n-1] is code[0], and the previous element of code[0] is code[n-1].

Given the circular array code and an integer key k, return the decrypted code to defuse the bomb!

class Solution:
    def decrypt(self, code: List[int], k: int) -> List[int]:
        n = len(code)
        double_code = code * 2
        for i in range(len(code)):
            if k == 0:
                code[i] = 0
            if k < 0:
                code[i] = sum(double_code[i + n + k: i + n])
            if k > 0:
                code[i] = sum(double_code[i + 1: i + k + 1])
        return code

You are given an m x n integer grid accounts where accounts[i][j] is the amount of money the i​​​​​​​​​​​th​​​​ customer has in the j​​​​​​​​​​​th​​​​ bank. Return the wealth that the richest customer has.

A customer's wealth is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum wealth.

class Solution:
    def maximumWealth(self, accounts: List[List[int]]) -> int:
        lst = []
        for element in accounts:
            lst.append(sum(element))
        return max(lst)

You are given a string allowed consisting of distinct characters and an array of strings words. A string is consistent if all characters in the string appear in the string allowed.

Return the number of consistent strings in the array words.

class Solution:
    def countConsistentStrings(self, allowed: str, words: List[str]) -> int:
        count = 0
        for element in words:
            while len(element) >= 1:
                print(element)
                if len(element) == 1 and element in allowed:
                    count += 1
                if element[0] in allowed:
                    element = element[1:]
                else:
                    break
        return count

You are given an integer n, the number of teams in a tournament that has strange rules:

If the current number of teams is even, each team gets paired with another team. A total of n / 2 matches are played, and n / 2 teams advance to the next round.
If the current number of teams is odd, one team randomly advances in the tournament, and the rest gets paired. A total of (n - 1) / 2 matches are played, and (n - 1) / 2 + 1 teams advance to the next round.
Return the number of matches played in the tournament until a winner is decided.

class Solution:
    def numberOfMatches(self, n: int) -> int:
        res= 0
        while n != 1:
            if n % 2 == 0:
                res += n // 2
                n = n // 2
            else:
                res += (n - 1) // 2
                n = (n - 1) // 2 + 1
        return res

You are given a string s of even length. Split this string into two halves of equal lengths, and let a be the first half and b be the second half.

Two strings are alike if they have the same number of vowels ('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'). Notice that s contains uppercase and lowercase letters.

Return true if a and b are alike. Otherwise, return false.

class Solution:
    def halvesAreAlike(self, s: str) -> bool:
        first = s[:len(s) // 2]
        second = s[len(s) // 2:]
        count1 = 0
        count2 = 0
        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']
        for i in range(len(first)):
            if first[i] in vowels:
                count1 += 1
        for i in range(len(second)):
            if second[i] in vowels:
                count2 += 1
        return count1 == count2

Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.

A string is represented by an array if the array elements concatenated in order forms the string.

class Solution:
    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:
        s1 = ''
        s2 = ''
        for i in range(len(word1)):
            s1 += word1[i]
        for i in range(len(word2)):
            s2 += word2[i]
        return s1 == s2

Hercy wants to save money for his first car. He puts money in the Leetcode bank every day.

He starts by putting in $1 on Monday, the first day. Every day from Tuesday to Sunday, he will put in $1 more than the day before. On every subsequent Monday, he will put in $1 more than the previous Monday.

Given n, return the total amount of money he will have in the Leetcode bank at the end of the nth day.

class Solution:
    def totalMoney(self, n: int) -> int:
        res = 0
        ans = 0
        for i in range(1, n + 1):
            if i % 7 != 1 or i == 1:
                res += 1
                ans += res
            else:
                res -= 5
                ans += res
        return ans

You are given an array rectangles where rectangles[i] = [li, wi] represents the ith rectangle of length li and width wi.

You can cut the ith rectangle to form a square with a side length of k if both k <= li and k <= wi. For example, if you have a rectangle [4,6], you can cut it to get a square with a side length of at most 4.

Let maxLen be the side length of the largest square you can obtain from any of the given rectangles.

Return the number of rectangles that can make a square with a side length of maxLen.

class Solution:
    def countGoodRectangles(self, rectangles: List[List[int]]) -> int:
        lst = []
        count = 0
        for element in rectangles:
            lst.append(min(element))
        for element in lst:
            if element == max(lst):
                count += 1
        return count

Given an integer array arr, return the mean of the remaining integers after removing the smallest 5% and the largest 5% of the elements.

Answers within 10-5 of the actual answer will be considered accepted.

class Solution:
    def trimMean(self, arr: List[int]) -> float:
        arr = sorted(arr)
        five_percent = len(arr) // 20
        arr = arr[five_percent:]
        arr = arr[:len(arr) - five_percent]
        return mean(arr)

There is a biker going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal 0.

You are given an integer array gain of length n where gain[i] is the net gain in altitude between points i​​​​​​ and i + 1 for all (0 <= i < n). Return the highest altitude of a point.

class Solution:
    def largestAltitude(self, gain: List[int]) -> int:
        altitude = 0
        lst = [0]
        for i in range(len(gain)):
            altitude += gain[i]
            lst.append(altitude)
            print(lst)
        return max(lst)

You are given an integer array nums. The unique elements of an array are the elements that appear exactly once in the array.

Return the sum of all the unique elements of nums.

class Solution:
    def sumOfUnique(self, nums: List[int]) -> int:
        d = {}
        lst = []
        for i in range(len(nums)):
            if nums[i] not in d.keys():
                d[nums[i]] = 1
            else:
                d[nums[i]] += 1
        print(d)
        for element in list(d.keys()):
            if d[element] == 1:
                lst.append(element)
        print(lst)
        return sum(lst)

You are given two strings word1 and word2. Merge the strings by adding letters in alternating order, starting with word1. If a string is longer than the other, append the additional letters onto the end of the merged string.

Return the merged string.

class Solution:
    def mergeAlternately(self, word1: str, word2: str) -> str:
        ans = ''
        if len(word1) > len(word2):
            for i in range(len(word2)):
                ans += word1[i]
                ans += word2[i]
            ans += word1[len(word2):]
        elif len(word1) == len(word2):
            for i in range(len(word2)):
                ans += word1[i]
                ans += word2[i]
        else:
            for i in range(len(word1)):
                ans += word1[i]
                ans += word2[i]
            ans += word2[len(word1):]
        return ans

You are working in a ball factory where you have n balls numbered from lowLimit up to highLimit inclusive (i.e., n == highLimit - lowLimit + 1), and an infinite number of boxes numbered from 1 to infinity.

Your job at this factory is to put each ball in the box with a number equal to the sum of digits of the ball's number. For example, the ball number 321 will be put in the box number 3 + 2 + 1 = 6 and the ball number 10 will be put in the box number 1 + 0 = 1.

Given two integers lowLimit and highLimit, return the number of balls in the box with the most balls.

class Solution:
    def countBalls(self, lowLimit: int, highLimit: int) -> int:
        d = {}
        s = 0
        for i in range(lowLimit, highLimit + 1):
            for j in range(len(str(i))):
                s += int(str(i)[j])
            if s not in d.keys():
                d[s] = 1
            else:
                d[s] += 1
            s = 0
        print(d)
        return max(list(d.values()))

There is an undirected star graph consisting of n nodes labeled from 1 to n. A star graph is a graph where there is one center node and exactly n - 1 edges that connect the center node with every other node.

You are given a 2D integer array edges where each edges[i] = [ui, vi] indicates that there is an edge between the nodes ui and vi. Return the center of the given star graph.

class Solution:
    def findCenter(self, edges: List[List[int]]) -> int:
        lst = []
        for element in edges:
            if element[0] in lst:
                return element[0]
            if element[1] in lst:
                return element[1]
            lst.append(element[0])
            lst.append(element[1])

You are given an integer array nums (0-indexed). In one operation, you can choose an element of the array and increment it by 1.

For example, if nums = [1,2,3], you can choose to increment nums[1] to make nums = [1,3,3].
Return the minimum number of operations needed to make nums strictly increasing.

An array nums is strictly increasing if nums[i] < nums[i+1] for all 0 <= i < nums.length - 1. An array of length 1 is trivially strictly increasing.

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return 0
        ans = 0
        print(nums)
        for i in range(0 , len(nums) - 1):
            if nums[i] >= nums[i + 1]:
                ans += nums[i] - nums[i + 1] + 1
                nums[i + 1] += nums[i] - nums[i + 1] + 1
        print(nums)
        if nums[len(nums) - 2] >= nums[len(nums) - 1]:
            ans += nums[len(nums) - 2] - nums[len(nums) - 1] + 1
        return ans

A sentence is a list of words that are separated by a single space with no leading or trailing spaces. Each of the words consists of only uppercase and lowercase English letters (no punctuation).

For example, "Hello World", "HELLO", and "hello world hello world" are all sentences.
You are given a sentence s​​​​​​ and an integer k​​​​​​. You want to truncate s​​​​​​ such that it contains only the first k​​​​​​ words. Return s​​​​​​ after truncating it.

class Solution:
    def truncateSentence(self, s: str, k: int) -> str:
        lst = s.split(' ')
        print(lst)
        ans = ''
        for i in range(k):
            ans += lst[i] + ' '
        ans = ans[:len(ans) - 1]
        return ans

The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.

For example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1.
Given an array nums, return the sum of all XOR totals for every subset of nums. 

Note: Subsets with the same elements should be counted multiple times.

An array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b.

class Solution:
    def subsetXORSum(self, nums: List[int]) -> int:
        def dfs(index, current):
            if index == len(nums):
                return current
            include = dfs(index + 1, current ^ nums[index])
            exclude = dfs(index + 1, current)
            return include + exclude
        return dfs(0,0)

You are given coordinates, a string that represents the coordinates of a square of the chessboard. Below is a chessboard for your reference.

Return true if the square is white, and false if the square is black.

The coordinate will always represent a valid chessboard square. The coordinate will always have the letter first, and the number second.

class Solution:
    def squareIsWhite(self, coordinates: str) -> bool:
        if coordinates[0] in ['a', 'c', 'e', 'g']:
            if int(coordinates[1]) % 2 == 1:
                return False
            else:
                return True
        else:
            if int(coordinates[1]) % 2 == 1:
                return True
            else:
                return False

Given an array of positive integers arr, return the sum of all possible odd-length subarrays of arr.

A subarray is a contiguous subsequence of the array.

class Solution:
    def sumOddLengthSubarrays(self, arr: List[int]) -> int:
        count = 0
        n = len(arr)
        for i in range(n):
            for j in range(i, n):
                new_arr = arr[i : j + 1]
                if len(new_arr) % 2 == 1:
                    count += sum(new_arr)
        return count

A sentence is a list of words that are separated by a single space with no leading or trailing spaces. Each word consists of lowercase and uppercase English letters.

A sentence can be shuffled by appending the 1-indexed word position to each word then rearranging the words in the sentence.

For example, the sentence "This is a sentence" can be shuffled as "sentence4 a3 is2 This1" or "is2 sentence4 This1 a3".
Given a shuffled sentence s containing no more than 9 words, reconstruct and return the original sentence.

class Solution:
    def sortSentence(self, s: str) -> str:
        arr = [element[-1] + element[:-1] for element in s.split()]
        arr = sorted(arr)
        arr1 = [element[1:] for element in arr]
        s = ''
        for element in arr1:
            s += element + ' '
        return s[:len(s) - 1]

Given a zero-based permutation nums (0-indexed), build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it.

A zero-based permutation nums is an array of distinct integers from 0 to nums.length - 1 (inclusive).

class Solution:
    def buildArray(self, nums: List[int]) -> List[int]:
        lst = []
        for i in range(len(nums)):
            lst.append(nums[nums[i]])
        return lst

You are given two integers, x and y, which represent your current location on a Cartesian grid: (x, y). You are also given an array points where each points[i] = [ai, bi] represents that a point exists at (ai, bi). A point is valid if it shares the same x-coordinate or the same y-coordinate as your location.

Return the index (0-indexed) of the valid point with the smallest Manhattan distance from your current location. If there are multiple, return the valid point with the smallest index. If there are no valid points, return -1.

The Manhattan distance between two points (x1, y1) and (x2, y2) is abs(x1 - x2) + abs(y1 - y2).

class Solution:
    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:
        lst = []
        for element in points:
            if element[0] == x or element[1] == y:
                lst.append(tuple(element))
        print(lst)
        if not lst:
            return -1
        d = {}
        for element in lst:
            d[element] = abs(element[0] - x) + abs(element[1] - y)
        for i in d.keys():
            if d[i] == min(d.values()):
                return points.index(list(i))

Given an integer array nums of length n, you want to create an array ans of length 2n where ans[i] == nums[i] and ans[i + n] == nums[i] for 0 <= i < n (0-indexed).

Specifically, ans is the concatenation of two nums arrays.

Return the array ans.

class Solution:
    def getConcatenation(self, nums: List[int]) -> List[int]:
        return nums * 2

You are given a 0-indexed string s that has lowercase English letters in its even indices and digits in its odd indices.

You must perform an operation shift(c, x), where c is a character and x is a digit, that returns the xth character after c.

For example, shift('a', 5) = 'f' and shift('x', 0) = 'x'.
For every odd index i, you want to replace the digit s[i] with the result of the shift(s[i-1], s[i]) operation.

Return s after replacing all digits. It is guaranteed that shift(s[i-1], s[i]) will never exceed 'z'.

Note that shift(c, x) is not a preloaded function, but an operation to be implemented as part of the solution.

class Solution:
    def replaceDigits(self, s: str) -> str:
        ans = ''
        lst = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
        def shift(c, number):
            return lst[lst.index(c) + number]
        for i in range(len(s)):
            if i % 2 == 0:
                ans += s[i]
            else:
                ans += shift(s[i - 1], int(s[i]))
        return ans

Given the head of a singly linked list, return the middle node of the linked list.

If there are two middle nodes, return the second middle node.

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:
        head1 = head
        head2 = head
        while head2 is not None and head2.next is not None:
            head1 = head1.next
            head2 = head2.next.next
        return head1

Given a string s, return true if s is a good string, or false otherwise.

A string s is good if all the characters that appear in s have the same number of occurrences (i.e., the same frequency).

class Solution:
    def areOccurrencesEqual(self, s: str) -> bool:
        d = {}
        for i in range(len(s)):
            if s[i] not in d.keys():
                d[s[i]] = 1
            else:
                d[s[i]] += 1
        for i in range(len(list(d.values())) - 1):
            if list(d.values())[i] == list(d.values())[i + 1]:
                continue
            else:
                return False
        return True

Given the root of a binary tree, return the sum of all left leaves.

A leaf is a node with no children. A left leaf is a leaf that is the left child of another node.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:
        def helper(root, is_left):
            if root is None:
                return 0
            if not root.left and not root.right:
                return root.val if is_left == True else 0
            return helper(root.left, True) + helper(root.right, False)
        return helper(root.left, True) + helper(root.right, False)

A self-dividing number is a number that is divisible by every digit it contains.

For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.
A self-dividing number is not allowed to contain the digit zero.

Given two integers left and right, return a list of all the self-dividing numbers in the range [left, right] (both inclusive).

class Solution:
    def selfDividingNumbers(self, left: int, right: int) -> List[int]:
        lst = []
        for element in range(left, right + 1):
            for i in range(len(str(element))):
                if i == len(str(element)) - 1:
                    if str(element)[i] == '0':
                        break
                    if element % int(str(element)[i]) == 0:
                        lst.append(element)
                if str(element)[i] == '0':
                    break
                if element % int(str(element)[i]) == 0:
                    continue
                else:
                    break
        return lst

A fancy string is a string where no three consecutive characters are equal.

Given a string s, delete the minimum possible number of characters from s to make it fancy.

Return the final string after the deletion. It can be shown that the answer will always be unique.

class Solution:
    def makeFancyString(self, s: str) -> str:
        i = 0
        ans = ''
        while i < len(s) - 2:
            if s[i] == s[i + 1] and s[i + 1] == s[i + 2]:
                i += 1
            else:
                ans += s[i]
                i += 1
        ans += s[i:]
        return ans

Given an integer array nums, return the greatest common divisor of the smallest number and largest number in nums.

The greatest common divisor of two numbers is the largest positive integer that evenly divides both numbers.

class Solution:
    def findGCD(self, nums: List[int]) -> int:
        lst = []
        for i in range(1, max(nums) + 1):
            if min(nums) % i == 0 and max(nums) % i == 0:
                lst.append(i)
        if not lst:
            return 1
        return max(lst)

Given an integer array nums and an integer k, return the number of pairs (i, j) where i < j such that |nums[i] - nums[j]| == k.

The value of |x| is defined as:

x if x >= 0.
-x if x < 0.

class Solution:
    def countKDifference(self, nums: List[int], k: int) -> int:
        count = 0
        for i in range(len(nums) - 1):
            for j in range(i + 1, len(nums)):
                if abs(nums[i] - nums[j]) == k:
                    count += 1
        return count

Given three integer arrays nums1, nums2, and nums3, return a distinct array containing all the values that are present in at least two out of the three arrays. You may return the values in any order.

class Solution:
    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:
        lst1 = []
        for i in range(len(nums1)):
            if nums1[i] not in lst1:
                lst1.append(nums1[i])
        lst2 = []
        for i in range(len(nums2)):
            if nums2[i] not in lst2:
                lst2.append(nums2[i])
        lst3 = []
        for i in range(len(nums3)):
            if nums3[i] not in lst3:
                lst3.append(nums3[i])
        lst4 = []
        for i in range(len(lst1)):
            if lst1[i] in lst2 or lst1[i] in lst3:
                lst4.append(lst1[i])
        for i in range(len(lst2)):
            if lst2[i] in lst3:
                lst4.append(lst2[i])
        lst5 = []
        for i in lst4:
            if i not in lst5:
                lst5.append(i)
        return lst5

Given a 0-indexed string word and a character ch, reverse the segment of word that starts at index 0 and ends at the index of the first occurrence of ch (inclusive). If the character ch does not exist in word, do nothing.

For example, if word = "abcdefd" and ch = "d", then you should reverse the segment that starts at 0 and ends at 3 (inclusive). The resulting string will be "dcbaefd".
Return the resulting string.

class Solution:
    def reversePrefix(self, word: str, ch: str) -> str:
        if ch not in word:
            return word
        for i in range(len(word)):
            if word[i] == ch:
                break
        return word[0 : i + 1][::-1] + word[i + 1:]

There is a programming language with only four operations and one variable X:

++X and X++ increments the value of the variable X by 1.
--X and X-- decrements the value of the variable X by 1.
Initially, the value of X is 0.

Given an array of strings operations containing a list of operations, return the final value of X after performing all the operations.

class Solution:
    def finalValueAfterOperations(self, operations: List[str]) -> int:
        res = 0
        for element in operations:
            if element == '--X' or element == 'X--':
                res -= 1
            if element == '++X' or element == 'X++':
                res += 1
        return res

A distinct string is a string that is present only once in an array.

Given an array of strings arr, and an integer k, return the kth distinct string present in arr. If there are fewer than k distinct strings, return an empty string "".

Note that the strings are considered in the order in which they appear in the array.

class Solution:
    def kthDistinct(self, arr: List[str], k: int) -> str:
        d = {}
        for i in range(len(arr)):
            if arr[i] not in d.keys():
                d[arr[i]] = 1
            else:
                d[arr[i]] += 1
        for i in list(d.keys()):
            if d[i] == 1:
                k -= 1
            if k == 0:
                return i
        return ''

A sentence is a list of tokens separated by a single space with no leading or trailing spaces. Every token is either a positive number consisting of digits 0-9 with no leading zeros, or a word consisting of lowercase English letters.

For example, "a puppy has 2 eyes 4 legs" is a sentence with seven tokens: "2" and "4" are numbers and the other tokens such as "puppy" are words.
Given a string s representing a sentence, you need to check if all the numbers in s are strictly increasing from left to right (i.e., other than the last number, each number is strictly smaller than the number on its right in s).

Return true if so, or false otherwise.

class Solution:
    def areNumbersAscending(self, s: str) -> bool:
        lst = []
        numbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
        for i in range(len(s)):
            if s[i] in numbers:
                if i + 1 < len(s): 
                    if s[i + 1] in numbers:
                        lst.append(s[i : i + 2])
                    elif s[i - 1] in numbers:
                        continue
                    else:
                        lst.append(s[i])
        if s[len(s) - 1] in numbers and s[len(s) - 2] not in numbers:
            lst.append(s[len(s) - 1])
        print(lst)
        while len(lst) >= 2:
            if int(lst[1]) <= int(lst[0]):
                return False
            lst = lst[1:]
        return True

Given a 0-indexed integer array nums, return the smallest index i of nums such that i mod 10 == nums[i], or -1 if such index does not exist.

x mod y denotes the remainder when x is divided by y.

class Solution:
    def smallestEqual(self, nums: List[int]) -> int:
        for i in range(len(nums)):
            if i % 10 == nums[i]:
                return i
        return -1

Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string "".

A string is palindromic if it reads the same forward and backward.

class Solution:
    def firstPalindrome(self, words: List[str]) -> str:
        for element in words:
            if element == element[::-1]:
                return element
        return ''

Given an integer n, return true if n has exactly three positive divisors. Otherwise, return false.

An integer m is a divisor of n if there exists an integer k such that n = k * m.

class Solution:
    def isThree(self, n: int) -> bool:
        count = 0
        for i in range(1, n + 1):
            print(i)
            if n % i == 0:
                count += 1
        return count == 3

A sentence is a list of words that are separated by a single space with no leading or trailing spaces.

You are given an array of strings sentences, where each sentences[i] represents a single sentence.

Return the maximum number of words that appear in a single sentence.

class Solution:
    def mostWordsFound(self, sentences: List[str]) -> int:
        lst = []
        for element in sentences:
            lst.append(len(element.split()))
        return max(lst)

You are given a string title consisting of one or more words separated by a single space, where each word consists of English letters. Capitalize the string by changing the capitalization of each word such that:

If the length of the word is 1 or 2 letters, change all letters to lowercase.
Otherwise, change the first letter to uppercase and the remaining letters to lowercase.
Return the capitalized title.

class Solution:
    def capitalizeTitle(self, title: str) -> str:
        lst = title.split()
        ans = ''
        for element in lst:
            if len(element) == 1 or len(element) == 2:
                element = element.lower()
                ans += element + ' '
            else:
                element = element.lower()
                element = element[0].upper() + element[1:]
                ans += element + ' '
        return ans[:len(ans) - 1]

A square triple (a,b,c) is a triple where a, b, and c are integers and a2 + b2 = c2.

Given an integer n, return the number of square triples such that 1 <= a, b, c <= n.

class Solution:
    def countTriples(self, n: int) -> int:
        count = 0
        for a in range(1, n + 1):
            for b in range(a, n + 1):
                for c in range(b, n + 1):
                    if a ** 2 + b ** 2 == c ** 2:
                        count += 1
        return count * 2

Given a string s consisting of only the characters 'a' and 'b', return true if every 'a' appears before every 'b' in the string. Otherwise, return false.

class Solution:
    def checkString(self, s: str) -> bool:
        if 'b' not in s:
            return True
        for i in range(len(s)):
            if s[i] == 'b':
                if 'a' in s[i + 1:]:
                    return False
                else:
                    return True

There are n availabe seats and n students standing in a room. You are given an array seats of length n, where seats[i] is the position of the ith seat. You are also given the array students of length n, where students[j] is the position of the jth student.

You may perform the following move any number of times:

Increase or decrease the position of the ith student by 1 (i.e., moving the ith student from position x to x + 1 or x - 1)
Return the minimum number of moves required to move each student to a seat such that no two students are in the same seat.

Note that there may be multiple seats or students in the same position at the beginning.

class Solution:
    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:
        seats = sorted(seats)
        students = sorted(students)
        ans = 0
        for i in range(len(seats)):
            ans += abs(seats[i] - students[i])
        return ans

Two strings word1 and word2 are considered almost equivalent if the differences between the frequencies of each letter from 'a' to 'z' between word1 and word2 is at most 3.

Given two strings word1 and word2, each of length n, return true if word1 and word2 are almost equivalent, or false otherwise.

The frequency of a letter x is the number of times it occurs in the string.

class Solution:
    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:
        d1 = {}
        d2 = {}
        diff = 0
        lst = []
        for i in range(len(word1)):
            if word1[i] not in d1.keys():
                d1[word1[i]] = 1
            else:
                d1[word1[i]] += 1
            if word2[i] not in d2.keys():
                d2[word2[i]] = 1
            else:
                d2[word2[i]] += 1
        for element in d1.keys():
            if element in d2.keys():
                diff += abs(d1[element] - d2[element])
                lst.append(diff)
                diff = 0
            else:
                diff += d1[element]
                lst.append(diff)
                diff = 0
        for element in d2.keys():
            if element in d1.keys():
                diff += abs(d2[element] - d1[element])
                lst.append(diff)
                diff = 0
            else:
                diff += d2[element]
                lst.append(diff)
                diff = 0
        return max(lst) <= 3

An n x n matrix is valid if every row and every column contains all the integers from 1 to n (inclusive).

Given an n x n integer matrix matrix, return true if the matrix is valid. Otherwise, return false.

class Solution:
    def checkValid(self, matrix: List[List[int]]) -> bool:
        for element in matrix:
            for i in range(1, len(matrix) + 1):
                if i not in element:
                    return False
        for element1 in list(zip(*matrix)):
            for i in range(1, len(matrix) + 1):
                if i not in element1:
                    return False
        return True

A string s can be partitioned into groups of size k using the following procedure:

The first group consists of the first k characters of the string, the second group consists of the next k characters of the string, and so on. Each element can be a part of exactly one group.
For the last group, if the string does not have k characters remaining, a character fill is used to complete the group.
Note that the partition is done so that after removing the fill character from the last group (if it exists) and concatenating all the groups in order, the resultant string should be s.

Given the string s, the size of each group k and the character fill, return a string array denoting the composition of every group s has been divided into, using the above procedure.

class Solution:
    def divideString(self, s: str, k: int, fill: str) -> List[str]:
        lst = []
        while len(s) >= k:
            lst.append(s[0:k])
            if len(s) == k:
                s = ''
            else:
                s = s[k:]
        if len(s) != 0:
            lst.append(s + fill * (k - len(s)))
        return lst

A bit flip of a number x is choosing a bit in the binary representation of x and flipping it from either 0 to 1 or 1 to 0.

For example, for x = 7, the binary representation is 111 and we may choose any bit (including any leading zeros not shown) and flip it. We can flip the first bit from the right to get 110, flip the second bit from the right to get 101, flip the fifth bit from the right (a leading zero) to get 10111, etc.
Given two integers start and goal, return the minimum number of bit flips to convert start to goal.

class Solution:
    def minBitFlips(self, start: int, goal: int) -> int:
        return sum(x == '1' for x in bin(start ^ goal))

Reversing an integer means to reverse all its digits.

For example, reversing 2021 gives 1202. Reversing 12300 gives 321 as the leading zeros are not retained.
Given an integer num, reverse num to get reversed1, then reverse reversed1 to get reversed2. Return true if reversed2 equals num. Otherwise return false.

class Solution:
    def isSameAfterReversals(self, num: int) -> bool:
        if num == 0:
            return True
        num = str(num)
        num1 = num[::-1]
        while num1[0] == '0':
            num1 = num1[1:]
        num2 = num1[::-1]
        while num2[0] == '0':
            num2 = num2[1:]
        print(num)
        print(num1)
        print(num2)
        return num2 == num

Given two string arrays words1 and words2, return the number of strings that appear exactly once in each of the two arrays.

class Solution:
    def countWords(self, words1: List[str], words2: List[str]) -> int:
        d1 = {}
        d2 = {}
        count = 0
        for element in words1:
            if element in d1.keys():
                d1[element] += 1
            else:
                d1[element] = 1
        for element in words2:
            if element in d2.keys():
                d2[element] += 1
            else:
                d2[element] = 1
        for element in d1.keys():
            if d1[element] == 1:
                if element in d2.keys():
                    if d2[element] == 1:
                        count += 1
        return count

You are given the root of a binary tree that consists of exactly 3 nodes: the root, its left child, and its right child.

Return true if the value of the root is equal to the sum of the values of its two children, or false otherwise.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def checkTree(self, root: Optional[TreeNode]) -> bool:
        if root.val == root.right.val + root.left.val:
            return True
        else:
            return False

You are given an integer array nums consisting of 2 * n integers.

You need to divide nums into n pairs such that:

Each element belongs to exactly one pair.
The elements present in a pair are equal.
Return true if nums can be divided into n pairs, otherwise return false.

class Solution:
    def divideArray(self, nums: List[int]) -> bool:
        d = {}
        for i in range(len(nums)):
            if nums[i] not in d.keys():
                d[nums[i]] = 1
            else:
                d[nums[i]] += 1
        for i in d.keys():
            if d[i] % 2 != 0:
                return False
        return True

Given a 0-indexed integer array nums, return the number of distinct quadruplets (a, b, c, d) such that:

nums[a] + nums[b] + nums[c] == nums[d], and
a < b < c < d

class Solution:
    def countQuadruplets(self, nums: List[int]) -> int:
        count = 0
        for i in range(len(nums) - 3):
            for j in range(i + 1, len(nums) - 2):
                for k in range(j + 1, len(nums) - 1):
                    for m in range(k + 1, len(nums)):
                        if nums[i] + nums[j] + nums[k] == nums[m]:
                            count += 1
        return count

You are given a string s consisting of lowercase English letters, and an integer k. Your task is to convert the string into an integer by a special process, and then transform it by summing its digits repeatedly k times. More specifically, perform the following steps:

Convert s into an integer by replacing each letter with its position in the alphabet (i.e. replace 'a' with 1, 'b' with 2, ..., 'z' with 26).
Transform the integer by replacing it with the sum of its digits.
Repeat the transform operation (step 2) k times in total.
For example, if s = "zbax" and k = 2, then the resulting integer would be 8 by the following operations:

Convert: "zbax" ➝ "(26)(2)(1)(24)" ➝ "262124" ➝ 262124
Transform #1: 262124 ➝ 2 + 6 + 2 + 1 + 2 + 4 ➝ 17
Transform #2: 17 ➝ 1 + 7 ➝ 8
Return the resulting integer after performing the operations described above.

class Solution:
    def getLucky(self, s: str, k: int) -> int:
        d = {'a' : '1', 'b' : '2', 'c' : '3', 'd' : '4', 'e' : '5', 'f' : '6', 'g' : '7', 'h' : '8', 'i' : '9', 'j' : '10', 'k' : '11', 'l' : '12', 'm' : '13', 'n' : '14', 'o' : '15', 'p' : '16', 'q' : '17', 'r' : '18', 's' : '19', 't' : '20', 'u' : '21', 'v' : '22', 'w' : '23', 'x' : '24', 'y' : '25', 'z' : '26'}
        ans = ''
        res = 0
        for i in range(len(s)):
            ans += d[s[i]]
        print(ans)
        while k > 0:
            res = 0
            for i in range(len(ans)):
                res += int(ans[i])
            res = str(res)
            ans = res
            k -= 1
        return int(ans)

Given a 0-indexed integer array nums of size n, find the maximum difference between nums[i] and nums[j] (i.e., nums[j] - nums[i]), such that 0 <= i < j < n and nums[i] < nums[j].

Return the maximum difference. If no such i and j exists, return -1.

class Solution:
    def maximumDifference(self, nums: List[int]) -> int:
        lst = []
        for i in range(len(nums) - 1):
            for j in range(i + 1, len(nums)):
                if nums[i] < nums[j]:
                    lst.append(nums[j] - nums[i])
        if not lst:
            return -1
        return max(lst)

You are given a 0-indexed integer array nums. Rearrange the values of nums according to the following rules:

Sort the values at odd indices of nums in non-increasing order.
For example, if nums = [4,1,2,3] before this step, it becomes [4,3,2,1] after. The values at odd indices 1 and 3 are sorted in non-increasing order.
Sort the values at even indices of nums in non-decreasing order.
For example, if nums = [4,1,2,3] before this step, it becomes [2,1,4,3] after. The values at even indices 0 and 2 are sorted in non-decreasing order.
Return the array formed after rearranging the values of nums.

class Solution:
    def sortEvenOdd(self, nums: List[int]) -> List[int]:
        if len(nums) == 1:
            return nums
        nums_odd = []
        nums_even = []
        lst = []
        for i in range(len(nums)):
            if i % 2 == 0:
                nums_even.append(nums[i])
            else:
                nums_odd.append(nums[i])
        nums_odd = list(reversed(sorted(nums_odd)))
        nums_even = sorted(nums_even)
        for i in range(len(nums_odd)):
            lst.append(nums_even[i])
            lst.append(nums_odd[i])
        if len(nums_even) > len(nums_odd):
            lst.append(nums_even[i + 1])
        return lst

Given a 0-indexed integer array nums of length n and an integer k, return the number of pairs (i, j) where 0 <= i < j < n, such that nums[i] == nums[j] and (i * j) is divisible by k.

class Solution:
    def countPairs(self, nums: List[int], k: int) -> int:
        count = 0 
        for i in range(len(nums) - 1):
            for j in range(i + 1, len(nums)):
                if nums[i] == nums[j] and (i * j) % k == 0:
                    count += 1
        return count

You are given an array of integers nums. You are also given an integer original which is the first number that needs to be searched for in nums.

You then do the following steps:

If original is found in nums, multiply it by two (i.e., set original = 2 * original).
Otherwise, stop the process.
Repeat this process with the new number as long as you keep finding the number.
Return the final value of original.

class Solution:
    def findFinalValue(self, nums: List[int], original: int) -> int:
        while original in nums:
            original = 2 * original
        return original

You are given an array of strings words and a string pref.

Return the number of strings in words that contain pref as a prefix.

A prefix of a string s is any leading contiguous substring of s.

class Solution:
    def prefixCount(self, words: List[str], pref: str) -> int:
        count = 0
        for element in words:
            for i in range(len(element)):
                if element[0:i + 1] == pref:
                    count += 1
        return count

Given two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2 where:

answer[0] is a list of all distinct integers in nums1 which are not present in nums2.
answer[1] is a list of all distinct integers in nums2 which are not present in nums1.
Note that the integers in the lists may be returned in any order.

class Solution:
    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:
        lst1 = []
        lst2 = []
        for i in range(len(nums1)):
            if nums1[i] not in nums2 and nums1[i] not in lst1:
                lst1.append(nums1[i])
        for i in range(len(nums2)):
            if nums2[i] not in nums1 and nums2[i] not in lst2:
                lst2.append(nums2[i])
        return [lst1, lst2]

You are given a string array words and a string s, where words[i] and s comprise only of lowercase English letters.

Return the number of strings in words that are a prefix of s.

A prefix of a string is a substring that occurs at the beginning of the string. A substring is a contiguous sequence of characters within a string.

class Solution:
    def countPrefixes(self, words: List[str], s: str) -> int:
        count = 0
        for element in words:
            if element == s[:len(element)]:
                count += 1
        return count

You are given a string num representing a large integer. An integer is good if it meets the following conditions:

It is a substring of num with length 3.
It consists of only one unique digit.
Return the maximum good integer as a string or an empty string "" if no such integer exists.

Note:

A substring is a contiguous sequence of characters within a string.
There may be leading zeroes in num or a good integer.

class Solution:
    def largestGoodInteger(self, num: str) -> str:
        lst = []
        for i in range(len(num) - 2):
            if num[i : i + 3][0] == num[i : i + 3][1] and num[i : i + 3][1] == num[i : i + 3][2]:
                lst.append(int(num[i : i + 3]))
        if not lst:
            return ''
        if str(max(lst)) == '0':
            return '000'
        return str(max(lst))

Given a string s and a character letter, return the percentage of characters in s that equal letter rounded down to the nearest whole percent.

class Solution:
    def percentageLetter(self, s: str, letter: str) -> int:
        count = 0 
        for i in range(len(s)):
            if s[i] == letter:
                count += 1
        print(count)
        return int(count / len(s) * 100)

You are given a 0-indexed, strictly increasing integer array nums and a positive integer diff. A triplet (i, j, k) is an arithmetic triplet if the following conditions are met:

i < j < k,
nums[j] - nums[i] == diff, and
nums[k] - nums[j] == diff.
Return the number of unique arithmetic triplets.

class Solution:
    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:
        count = 0
        for i in range(len(nums) - 2):
            for j in range(i + 1, len(nums) - 1):
                for k in range(j + 1, len(nums)):
                    if nums[j] - nums[i] == diff and nums[k] - nums[j] == diff:
                        count += 1 
        return count

You are given two 2D integer arrays, items1 and items2, representing two sets of items. Each array items has the following properties:

items[i] = [valuei, weighti] where valuei represents the value and weighti represents the weight of the ith item.
The value of each item in items is unique.
Return a 2D integer array ret where ret[i] = [valuei, weighti], with weighti being the sum of weights of all items with value valuei.

Note: ret should be returned in ascending order by value.

class Solution:
    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:
        d = {}
        lst = []
        for element in items1:
            d[element[0]] = element[1]
        for element in items2:
            if element[0] in d.keys():
                d[element[0]] += element[1]
            else:
                d[element[0]] = element[1]
        print(d)
        d = dict(sorted(d.items()))
        for i in list(d.keys()):
            lst.append([i, d[i]])
        return lst

Given a positive integer n, return the smallest positive integer that is a multiple of both 2 and n.

class Solution:
    def smallestEvenMultiple(self, n: int) -> int:
        if n % 2 == 0:
            return n
        else:
            return 2 * n

You are given a 0-indexed integer array nums. In one operation, you may do the following:

Choose two integers in nums that are equal.
Remove both integers from nums, forming a pair.
The operation is done on nums as many times as possible.

Return a 0-indexed integer array answer of size 2 where answer[0] is the number of pairs that are formed and answer[1] is the number of leftover integers in nums after doing the operation as many times as possible.

class Solution:
    def numberOfPairs(self, nums: List[int]) -> List[int]:
        pair = 0
        nums = sorted(nums)
        i = 0
        remain = 0
        while len(nums) >= 2:
            if nums[i] == nums[i + 1]:
                pair += 1
                nums = nums[2:]
            else:
                nums = nums[1:]
                remain += 1
            print(nums)
        remain = remain + len(nums)
        return [pair, remain]

Given two positive integers a and b, return the number of common factors of a and b.

An integer x is a common factor of a and b if x divides both a and b.

class Solution:
    def commonFactors(self, a: int, b: int) -> int:
        lst1 = []
        lst2 = []
        count = 0
        for i in range(1, a + 1):
            if a % i == 0:
                lst1.append(i)
        print(lst1)
        for i in range(1, b + 1):
            if b % i == 0:
                lst2.append(i)
        print(lst2)
        if a > b:
            for i in range(len(lst2)):
                if lst2[i] in lst1:
                    count += 1
        else:
            for i in range(len(lst1)):
                if lst1[i] in lst2:
                    count += 1
        return count

You are given a non-negative floating point number rounded to two decimal places celsius, that denotes the temperature in Celsius.

You should convert Celsius into Kelvin and Fahrenheit and return it as an array ans = [kelvin, fahrenheit].

Return the array ans. Answers within 10-5 of the actual answer will be accepted.

class Solution:
    def convertTemperature(self, celsius: float) -> List[float]:
        return [celsius + 273.15, celsius * 1.8 + 32]

You are given a 0-indexed array nums of size n consisting of non-negative integers.

You need to apply n - 1 operations to this array where, in the ith operation (0-indexed), you will apply the following on the ith element of nums:

If nums[i] == nums[i + 1], then multiply nums[i] by 2 and set nums[i + 1] to 0. Otherwise, you skip this operation.
After performing all the operations, shift all the 0's to the end of the array.

For example, the array [1,0,2,0,0,1] after shifting all its 0's to the end, is [1,2,1,0,0,0].
Return the resulting array.

Note that the operations are applied sequentially, not all at once.

class Solution:
    def applyOperations(self, nums: List[int]) -> List[int]:
        for i in range(len(nums) - 1):
            if nums[i] == nums[i + 1]:
                nums[i] = nums[i] * 2
                nums[i + 1] = 0
        for i in range(len(nums)):
            if nums[i] == 0:
                nums.remove(0)
                nums.append(0)
        return nums

You are given a 0-indexed array of positive integers nums. Find the number of triplets (i, j, k) that meet the following conditions:

0 <= i < j < k < nums.length
nums[i], nums[j], and nums[k] are pairwise distinct.
In other words, nums[i] != nums[j], nums[i] != nums[k], and nums[j] != nums[k].
Return the number of triplets that meet the conditions.

class Solution:
    def unequalTriplets(self, nums: List[int]) -> int:
        count = 0
        for i in range(len(nums) - 2):
            for j in range(i + 1, len(nums) - 1):
                for k in range(j + 1, len(nums)):
                    if nums[i] != nums[j]:
                        if nums[j] != nums[k]:
                            if nums[i] != nums[k]:
                                count += 1
        return count

Given a positive integer n, find the pivot integer x such that:

The sum of all elements between 1 and x inclusively equals the sum of all elements between x and n inclusively.
Return the pivot integer x. If no such integer exists, return -1. It is guaranteed that there will be at most one pivot index for the given input.

class Solution:
    def pivotInteger(self, n: int) -> int:
        if n == 1:
            return 1
        init = 0
        res = sum([i for i in range(n + 1)])
        lst = []
        #print(res)
        for i in range(1, n + 1):
            init += i
            if init == res:
                return i
            res -= i
            print(init)
            print(res)
        return -1

Given an integer num, return the number of digits in num that divide num.

An integer val divides nums if nums % val == 0.

class Solution:
    def countDigits(self, num: int) -> int:
        count = 0
        for i in range(len(str(num))):
            if int(str(num)[i]) != 0 and num % int(str(num)[i]) == 0:
                count += 1
        return count

You are given a positive integer array nums.

The element sum is the sum of all the elements in nums.
The digit sum is the sum of all the digits (not necessarily distinct) that appear in nums.
Return the absolute difference between the element sum and digit sum of nums.

Note that the absolute difference between two integers x and y is defined as |x - y|.

class Solution:
    def differenceOfSum(self, nums: List[int]) -> int:
        sum1 = 0
        sum2 = 0
        for element in nums:
            sum1 += element
            for i in range(len(str(element))):
                sum2 += int(str(element)[i])
        return abs(sum1 - sum2)

You are given a positive integer n. Each digit of n has a sign according to the following rules:

The most significant digit is assigned a positive sign.
Each other digit has an opposite sign to its adjacent digits.
Return the sum of all digits with their corresponding sign.

class Solution:
    def alternateDigitSum(self, n: int) -> int:
        ans = 0
        for i in range(len(str(n))):
            if i % 2 == 0:
                ans += int(str(n)[i])
            else:
                ans += -int(str(n)[i])
        return ans

Given an array of positive integers nums, return an array answer that consists of the digits of each integer in nums after separating them in the same order they appear in nums.

To separate the digits of an integer is to get all the digits it has in the same order.

For example, for the integer 10921, the separation of its digits is [1,0,9,2,1].

class Solution:
    def separateDigits(self, nums: List[int]) -> List[int]:
        ans = []
        for element in nums:
            for i in range(len(str(element))):
                ans += [int(str(element)[i])]
        return ans

You are given two 2D integer arrays nums1 and nums2.

nums1[i] = [idi, vali] indicate that the number with the id idi has a value equal to vali.
nums2[i] = [idi, vali] indicate that the number with the id idi has a value equal to vali.
Each array contains unique ids and is sorted in ascending order by id.

Merge the two arrays into one array that is sorted in ascending order by id, respecting the following conditions:

Only ids that appear in at least one of the two arrays should be included in the resulting array.
Each id should be included only once and its value should be the sum of the values of this id in the two arrays. If the id does not exist in one of the two arrays, then assume its value in that array to be 0.
Return the resulting array. The returned array must be sorted in ascending order by id.

class Solution:
    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:
        d = {}
        lst = []
        for element in nums1:
            d[element[0]] = element[1]
        for element in nums2:
            if element[0] in d.keys():
                d[element[0]] += element[1]
            else:
                d[element[0]] = element[1]
        print(d)
        d = dict(sorted(d.items(), key = lambda item: item[0]))
        for element in list(d.keys()):
            lst.append([element, d[element]])
        return lst

Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.

Return the positive integer k. If there is no such integer, return -1.

class Solution:
    def findMaxK(self, nums: List[int]) -> int:
        lst = []
        for element in nums:
            if element > 0 and -element in nums:
                lst.append(element)
        if not lst:
            return -1
        return max(lst)

You are given a 0-indexed integer array nums of size n.

Define two arrays leftSum and rightSum where:

leftSum[i] is the sum of elements to the left of the index i in the array nums. If there is no such element, leftSum[i] = 0.
rightSum[i] is the sum of elements to the right of the index i in the array nums. If there is no such element, rightSum[i] = 0.
Return an integer array answer of size n where answer[i] = |leftSum[i] - rightSum[i]|.

class Solution:
    def leftRightDifference(self, nums: List[int]) -> List[int]:
        lst = []
        for i in range(len(nums)):
            if i == 0:
                lst.append(abs(-sum(nums[i + 1:])))
            elif i == len(nums) - 1:
                lst.append(abs(sum(nums[:i])))
            else:
                lst.append(abs(sum(nums[:i]) - sum(nums[i + 1:])))
        return lst

You are given a 0-indexed integer array nums and an integer k. Your task is to perform the following operation exactly k times in order to maximize your score:

Select an element m from nums.
Remove the selected element m from the array.
Add a new element with a value of m + 1 to the array.
Increase your score by m.
Return the maximum score you can achieve after performing the operation exactly k times.

class Solution:
    def maximizeSum(self, nums: List[int], k: int) -> int:
        ans = 0
        while k != 0:
            maxi = max(nums)
            ans += maxi
            nums.remove(maxi)
            nums.append(maxi + 1)
            print(nums)
            k -= 1
        return ans

Given a positive integer n, find the sum of all integers in the range [1, n] inclusive that are divisible by 3, 5, or 7.

Return an integer denoting the sum of all numbers in the given range satisfying the constraint.

class Solution:
    def sumOfMultiples(self, n: int) -> int:
        ans = 0
        for i in range(1, n + 1):
            if i % 3 == 0:
                ans += i
                continue
            if i % 5 == 0:
                ans += i
                continue
            if i % 7 == 0:
                ans += i
                continue
        return ans

Given a positive integer num represented as a string, return the integer num without trailing zeros as a string.

class Solution:
    def removeTrailingZeros(self, num: str) -> str:
        num = num[::-1]
        while num[0] == '0':
            num = num[1:]
        return num[::-1]

Given an integer array nums containing distinct positive integers, find and return any number from the array that is neither the minimum nor the maximum value in the array, or -1 if there is no such number.

Return the selected integer.

class Solution:
    def findNonMinOrMax(self, nums: List[int]) -> int:
        for element in nums:
            if element != min(nums) and element != max(nums):
                return element
        return -1

Given two integers, num and t. A number x is achievable if it can become equal to num after applying the following operation at most t times:

Increase or decrease x by 1, and simultaneously increase or decrease num by 1.
Return the maximum possible value of x.

class Solution:
    def theMaximumAchievableX(self, num: int, t: int) -> int:
        return num + 2 * t

You are given a 1-indexed integer array nums of length n.

An element nums[i] of nums is called special if i divides n, i.e. n % i == 0.

Return the sum of the squares of all special elements of nums.

class Solution:
    def sumOfSquares(self, nums: List[int]) -> int:
        ans = 0
        n = len(nums)
        for i in range(len(nums)):
            if n % (i + 1) == 0:
                ans += nums[i] ** 2
        return ans

There are n employees in a company, numbered from 0 to n - 1. Each employee i has worked for hours[i] hours in the company.

The company requires each employee to work for at least target hours.

You are given a 0-indexed array of non-negative integers hours of length n and a non-negative integer target.

Return the integer denoting the number of employees who worked at least target hours.

class Solution:
    def numberOfEmployeesWhoMetTarget(self, hours: List[int], target: int) -> int:
        ans = 0
        for i in range(len(hours)):
            if hours[i] >= target:
                ans += 1
        return ans

Given a m x n binary matrix mat, find the 0-indexed position of the row that contains the maximum count of ones, and the number of ones in that row.

In case there are multiple rows that have the maximum count of ones, the row with the smallest row number should be selected.

Return an array containing the index of the row, and the number of ones in it.

class Solution:
    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:
        d = {}
        for i in range(len(mat)):
            d[i] = 0
            for j in range(len(mat[i])):
                if mat[i][j]  == 1:
                    d[i] += 1
        index = list(d.values()).index(max(list(d.values())))
        value = max(d.values())
        return [index, value]  

Given a string s, you have two types of operation:

Choose an index i in the string, and let c be the character in position i. Delete the closest occurrence of c to the left of i (if exists).
Choose an index i in the string, and let c be the character in position i. Delete the closest occurrence of c to the right of i (if exists).
Your task is to minimize the length of s by performing the above operations zero or more times.

Return an integer denoting the length of the minimized string.

class Solution:
    def minimizedStringLength(self, s: str) -> int:
        lst = []
        for i in range(len(s)):
            if s[i] not in lst:
                lst.append(s[i])
        return len(lst)

Given a 0-indexed integer array nums of length n and an integer target, return the number of pairs (i, j) where 0 <= i < j < n and nums[i] + nums[j] < target.

class Solution:
    def countPairs(self, nums: List[int], target: int) -> int:
        count = 0
        for i in range(len(nums) - 1):
            for j in range(i + 1, len(nums)):
                if nums[i] + nums[j] < target:
                    count += 1
        return count

Given an array of strings words and a string s, determine if s is an acronym of words.

The string s is considered an acronym of words if it can be formed by concatenating the first character of each string in words in order. For example, "ab" can be formed from ["apple", "banana"], but it can't be formed from ["bear", "aardvark"].

Return true if s is an acronym of words, and false otherwise.

class Solution:
    def isAcronym(self, words: List[str], s: str) -> bool:
        ans = ''
        for element in words:
            ans += element[0]
        return ans == s

You are given two positive integers low and high.

An integer x consisting of 2 * n digits is symmetric if the sum of the first n digits of x is equal to the sum of the last n digits of x. Numbers with an odd number of digits are never symmetric.

Return the number of symmetric integers in the range [low, high].

class Solution:
    def countSymmetricIntegers(self, low: int, high: int) -> int:
        lst1 = []
        lst2 = []
        count = 0
        for i in range(low, high + 1, 1):
            if len(str(i)) % 2 == 1:
                continue
            for j in range(len(str(i)) // 2):
                lst1.append(int(str(i)[j]))
            for k in range(len(str(i)) // 2, len(str(i)), 1):
                lst2.append(int(str(i)[k]))
            if sum(lst1) == sum(lst2):
                count += 1
            lst1 = []
            lst2 = []
        return count

You are given a binary string s that contains at least one '1'.

You have to rearrange the bits in such a way that the resulting binary number is the maximum odd binary number that can be created from this combination.

Return a string representing the maximum odd binary number that can be created from the given combination.

Note that the resulting string can have leading zeros.

class Solution:
    def maximumOddBinaryNumber(self, s: str) -> str:
        count = 0
        ans = ''
        for i in range(len(s)):
            if s[i] == '1':
                count += 1
        while count != 1:
            ans += '1'
            count -= 1
        while len(ans) < len(s) - 1:
            ans += '0'
        ans = ans + '1'
        return ans

You are given a 0-indexed 2D integer array nums representing the coordinates of the cars parking on a number line. For any index i, nums[i] = [starti, endi] where starti is the starting point of the ith car and endi is the ending point of the ith car.

Return the number of integer points on the line that are covered with any part of a car.

class Solution:
    def numberOfPoints(self, nums: List[List[int]]) -> int:
        lst = []
        for element in nums:
            for i in range(element[0], element[1] + 1, 1):
                if i not in lst:
                    lst.append(i)
        return len(lst)

Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.

You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.

Return the final string that will be present on your laptop screen.

class Solution:
    def finalString(self, s: str) -> str:
        ans = ''
        for i in range(len(s)):
            if s[i] != 'i':
                ans += s[i]
            else:
                ans = ans[::-1]
        return ans

You are given an integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the largest digit in both numbers is equal.

For example, 2373 is made up of three distinct digits: 2, 3, and 7, where 7 is the largest among them.

Return the maximum sum or -1 if no such pair exists.

class Solution:
    def maxSum(self, nums: List[int]) -> int:
        biggest = 0
        lst = []
        lst2 = []
        lst3 = []
        for element in nums:
            for i in range(len(str(element))):
                if int(str(element)[i]) > biggest:
                    biggest = int(str(element)[i])
            lst.append(biggest)
            biggest = 0
        for i in range(len(lst)):
            if lst[i] in lst3:
                break
            else:
                lst3.append(lst[i])
            if i == len(lst) - 1:
                return -1
        for i in range(len(lst) - 1):
            for j in range(i + 1, len(lst)):
                if lst[i] == lst[j]:
                    lst2.append(nums[i] + nums[j])
        return max(lst2)

An array is considered special if the parity of every pair of adjacent elements is different. In other words, one element in each pair must be even, and the other must be odd.

You are given an array of integers nums. Return true if nums is a special array, otherwise, return false.

class Solution:
    def isArraySpecial(self, nums: List[int]) -> bool:
        if nums[0] % 2 == 1:
            for i in range(len(nums)):
                if i % 2 == 0 and nums[i] % 2 != 1:
                    return False
                if i % 2 == 1 and nums[i] % 2 != 0:
                    return False
        else:
            for i in range(len(nums)):
                if i % 2 == 1 and nums[i] % 2 != 1:
                    return False
                if i % 2 == 0 and nums[i] % 2 != 0:
                    return False
        return True

Given a 0-indexed m x n integer matrix matrix, create a new 0-indexed matrix called answer. Make answer equal to matrix, then replace each element with the value -1 with the maximum element in its respective column.

Return the matrix answer.

class Solution:
    def modifiedMatrix(self, matrix: List[List[int]]) -> List[List[int]]:
        answer = matrix
        for element in matrix:
            for i in range(len(element)):
                if element[i] == -1:
                    element[i] = max([element[i] for element in matrix])
        return answer

You are given an array nums, where each number in the array appears either once or twice.

Return the bitwise XOR of all the numbers that appear twice in the array, or 0 if no number appears twice.

class Solution:
    def duplicateNumbersXOR(self, nums: List[int]) -> int:
        d = {}
        lst = []
        value = 0
        for element in nums:
            if element not in d.keys():
                d[element] = 1
            else:
                d[element] += 1
        for element in list(d.keys()):
            if d[element] == 2:
                lst.append(element)
        for element in lst:
            value = value ^ element
        return value

You are given a string s. The score of a string is defined as the sum of the absolute difference between the ASCII values of adjacent characters.

Return the score of s.

class Solution:
    def scoreOfString(self, s: str) -> int:
        ans = 0
        for i in range(len(s) - 1):
            ans += abs(ord(s[i]) - ord(s[i + 1]))
        return ans

You are given two arrays of equal length, nums1 and nums2.

Each element in nums1 has been increased (or decreased in the case of negative) by an integer, represented by the variable x.

As a result, nums1 becomes equal to nums2. Two arrays are considered equal when they contain the same integers with the same frequencies.

Return the integer x.

class Solution:
    def addedInteger(self, nums1: List[int], nums2: List[int]) -> int:
        nums1 = sorted(nums1)
        nums2 = sorted(nums2)
        return nums2[0] - nums1[0]

You are given 2 integer arrays nums1 and nums2 of lengths n and m respectively. You are also given a positive integer k.

A pair (i, j) is called good if nums1[i] is divisible by nums2[j] * k (0 <= i <= n - 1, 0 <= j <= m - 1).

Return the total number of good pairs.

class Solution:
    def numberOfPairs(self, nums1: List[int], nums2: List[int], k: int) -> int:
        count = 0
        for i in range(len(nums1)):
            for j in range(len(nums2)):
                if nums1[i] % (nums2[j] * k) == 0:
                    count += 1
        return count

You are given two strings s and t such that every character occurs at most once in s and t is a permutation of s.

The permutation difference between s and t is defined as the sum of the absolute difference between the index of the occurrence of each character in s and the index of the occurrence of the same character in t.

Return the permutation difference between s and t.

class Solution:
    def findPermutationDifference(self, s: str, t: str) -> int:
        ans = 0
        for i in range(len(s)):
            ans += abs(i - t.index(s[i]))
        return ans

Given an integer array hours representing times in hours, return an integer denoting the number of pairs i, j where i < j and hours[i] + hours[j] forms a complete day.

A complete day is defined as a time duration that is an exact multiple of 24 hours.

For example, 1 day is 24 hours, 2 days is 48 hours, 3 days is 72 hours, and so on.

class Solution:
    def countCompleteDayPairs(self, hours: List[int]) -> int:
        count = 0
        for i in range(len(hours) - 1):
            for j in range(i + 1, len(hours)):
                if (hours[i] + hours[j]) % 24 == 0:
                    count += 1
        return count

You are given an integer array nums. In one operation, you can add or subtract 1 from any element of nums.

Return the minimum number of operations to make all elements of nums divisible by 3.

class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        count = 0
        for i in range(len(nums)):
            if nums[i] <= 3:
                if nums[i] == 1:
                    count += 1
                elif nums[i] == 2:
                    count += 1
                else:
                    continue
            else:
                if nums[i] % 3 == 1:
                    count += 1
                elif nums[i] % 3 == 2:
                    count += 1
                else:
                    continue
        return count

You have an array of floating point numbers averages which is initially empty. You are given an array nums of n integers where n is even.

You repeat the following procedure n / 2 times:

Remove the smallest element, minElement, and the largest element maxElement, from nums.
Add (minElement + maxElement) / 2 to averages.
Return the minimum element in averages.

class Solution:
    def minimumAverage(self, nums: List[int]) -> float:
        lst = []
        while nums:
            lst.append((max(nums) + min(nums)) / 2)
            nums.remove(max(nums))
            nums.remove(min(nums))
            print(nums)
            if nums:
                lst.append((max(nums) + min(nums)) / 2)
            print(lst)
        return min(lst)

You are given an array of positive integers nums.

Alice and Bob are playing a game. In the game, Alice can choose either all single-digit numbers or all double-digit numbers from nums, and the rest of the numbers are given to Bob. Alice wins if the sum of her numbers is strictly greater than the sum of Bob's numbers.

Return true if Alice can win this game, otherwise, return false.

class Solution:
    def canAliceWin(self, nums: List[int]) -> bool:
        lst1 = []
        lst2 = []
        for element in nums:
            if len(str(element)) == 2:
                lst1.append(element)
            else:
                lst2.append(element) 
        return sum(lst1) > sum(lst2) or sum(lst2) > sum(lst1)

There is a snake in an n x n matrix grid and can move in four possible directions. Each cell in the grid is identified by the position: grid[i][j] = (i * n) + j.

The snake starts at cell 0 and follows a sequence of commands.

You are given an integer n representing the size of the grid and an array of strings commands where each command[i] is either "UP", "RIGHT", "DOWN", and "LEFT". It's guaranteed that the snake will remain within the grid boundaries throughout its movement.

Return the position of the final cell where the snake ends up after executing commands.

class Solution:
    def finalPositionOfSnake(self, n: int, commands: List[str]) -> int:
        i = 0
        j = 0
        for element in commands:
            if element == 'RIGHT':
                j += 1
            if element == 'LEFT':
                j -= 1
            if element == 'UP':
                i -= 1
            if element == 'DOWN':
                i += 1
        return i * n + j

You are given three positive integers num1, num2, and num3.

The key of num1, num2, and num3 is defined as a four-digit number such that:

Initially, if any number has less than four digits, it is padded with leading zeros.
The ith digit (1 <= i <= 4) of the key is generated by taking the smallest digit among the ith digits of num1, num2, and num3.
Return the key of the three numbers without leading zeros (if any).

class Solution:
    def generateKey(self, num1: int, num2: int, num3: int) -> int:
        key = ''
        s_num1 = str(num1)
        s_num2 = str(num2)
        s_num3 = str(num3)
        while len(s_num1) < 4:
            s_num1 = '0' + s_num1
        while len(s_num2) < 4:
            s_num2 = '0' + s_num2
        while len(s_num3) < 4:
            s_num3 = '0' + s_num3
        for i in range(len(s_num1)):
            key = str(min([int(s_num1[i]), int(s_num2[i]), int(s_num3[i])])) + key
        key = key[::-1]
        while len(key) > 1:
            if key[0] == '0':
                key = key[1:]
            if key[0] != '0':
                break
        return int(key)

You are given an integer array nums, an integer k, and an integer multiplier.

You need to perform k operations on nums. In each operation:

Find the minimum value x in nums. If there are multiple occurrences of the minimum value, select the one that appears first.
Replace the selected minimum value x with x * multiplier.
Return an integer array denoting the final state of nums after performing all k operations.

class Solution:
    def getFinalState(self, nums: List[int], k: int, multiplier: int) -> List[int]:
        while k != 0:
            min_index = nums.index(min(nums))
            nums = nums[:min_index] + [min(nums) * multiplier] + nums[min_index + 1:]
            k -= 1
        return nums

You are given a string date representing a Gregorian calendar date in the yyyy-mm-dd format.

date can be written in its binary representation obtained by converting year, month, and day to their binary representations without any leading zeroes and writing them down in year-month-day format.

Return the binary representation of date.

class Solution:
    def convertDateToBinary(self, date: str) -> str:
        lst = date.split('-')
        ans = ''
        for i in range(len(lst)):
            if i != len(lst) - 1:
                ans += bin(int(lst[i]))[2:] + '-'
            else:
                ans += bin(int(lst[i]))[2:]
        return ans

You are given a string s. Simulate events at each second i:

If s[i] == 'E', a person enters the waiting room and takes one of the chairs in it.
If s[i] == 'L', a person leaves the waiting room, freeing up a chair.
Return the minimum number of chairs needed so that a chair is available for every person who enters the waiting room given that it is initially empty.

class Solution:
    def minimumChairs(self, s: str) -> int:
        ans = 0
        lst = []
        if 'L' in s:
            for i in range(len(s)):
                if s[i] == 'E':
                    ans += 1
                    lst.append(ans)
                if s[i] == 'L':
                    ans -= 1
                    lst.append(ans)
                print(lst)
        else:
            for i in range(len(s)):
                if s[i] == 'E':
                    ans += 1
            lst.append(ans)
        return max(lst)

You are given two strings, coordinate1 and coordinate2, representing the coordinates of a square on an 8 x 8 chessboard.

Below is the chessboard for reference.

Return true if these two squares have the same color and false otherwise.

The coordinate will always represent a valid chessboard square. The coordinate will always have the letter first (indicating its column), and the number second (indicating its row).

class Solution:
    def checkTwoChessboards(self, coordinate1: str, coordinate2: str) -> bool:
        lst = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
        if (lst.index(coordinate1[0]) - lst.index(coordinate2[0])) % 2 == 0:
            if abs(int(coordinate1[1]) - int(coordinate2[1])) % 2 == 0:
                return True
            else:
                return False
        else:
            if abs(int(coordinate1[1]) - int(coordinate2[1])) % 2 == 0:
                return False
            else:
                return True

There are n mountains in a row, and each mountain has a height. You are given an integer array height where height[i] represents the height of mountain i, and an integer threshold.

A mountain is called stable if the mountain just before it (if it exists) has a height strictly greater than threshold. Note that mountain 0 is not stable.

Return an array containing the indices of all stable mountains in any order.

class Solution:
    def stableMountains(self, height: List[int], threshold: int) -> List[int]:
        lst = []
        for i in range(1, len(height)):
            if  height[i - 1] > threshold:
                lst.append(i)
        return lst

In the town of Digitville, there was a list of numbers called nums containing integers from 0 to n - 1. Each number was supposed to appear exactly once in the list, however, two mischievous numbers sneaked in an additional time, making the list longer than usual.

As the town detective, your task is to find these two sneaky numbers. Return an array of size two containing the two numbers (in any order), so peace can return to Digitville.

class Solution:
    def getSneakyNumbers(self, nums: List[int]) -> List[int]:
        d = {}
        lst = []
        for element in nums:
            if element in d.keys():
                d[element] += 1
            else:
                d[element] = 1
        for element in d.keys():
            if d[element] == 2:
                lst.append(element)
        return lst

You are given an integer array nums.

You replace each element in nums with the sum of its digits.

Return the minimum element in nums after all replacements.

class Solution:
    def minElement(self, nums: List[int]) -> int:
        lst = []
        s = 0
        for element in nums:
            for i in range(len(str(element))):
                s += int(str(element)[i])
            lst.append(s)
            s = 0
        print(lst)
        return min(lst)

Alice and Bob are playing a game. Initially, Alice has a string word = "a".

You are given a positive integer k.

Now Bob will ask Alice to perform the following operation forever:

Generate a new string by changing each character in word to its next character in the English alphabet, and append it to the original word.
For example, performing the operation on "c" generates "cd" and performing the operation on "zb" generates "zbac".

Return the value of the kth character in word, after enough operations have been done for word to have at least k characters.

class Solution:
    def kthCharacter(self, k: int) -> str:
        add = ''
        word = 'a'
        lst = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
        while len(word) < k:
            for i in range(len(word)):
                if word[i] != 'z':
                    add += lst[lst.index(word[i]) + 1]
                else:
                    add += 'a'
            word = word + add
            add = ''
        return word[k - 1]

You are given a string num consisting of only digits. A string of digits is called balanced if the sum of the digits at even indices is equal to the sum of digits at odd indices.

Return true if num is balanced, otherwise return false.

class Solution:
    def isBalanced(self, num: str) -> bool:
        sum1 = 0
        sum2 = 0
        for i in range(0, len(num), 2):
            sum1 += int(num[i])
        for j in range(1, len(num), 2):
            sum2 += int(num[j])
        return sum1 == sum2

You are given an integer array nums. Transform nums by performing the following operations in the exact order specified:

Replace each even number with 0.
Replace each odd numbers with 1.
Sort the modified array in non-decreasing order.
Return the resulting array after performing these operations.

class Solution:
    def transformArray(self, nums: List[int]) -> List[int]:
        for i in range(len(nums)):
            if nums[i] % 2 == 0:
                nums = nums[:i] + [0] + nums[i + 1:]
            else:
                nums = nums[:i] + [1] + nums[i + 1:]
        nums = sorted(nums)
        return nums

You are given a string s consisting of digits. Perform the following operation repeatedly until the string has exactly two digits:

For each pair of consecutive digits in s, starting from the first digit, calculate a new digit as the sum of the two digits modulo 10.
Replace s with the sequence of newly calculated digits, maintaining the order in which they are computed.
Return true if the final two digits in s are the same; otherwise, return false.

class Solution:
    def hasSameDigits(self, s: str) -> bool:
        ans = ''
        while len(s) > 2:
            for i in range(len(s) - 1):
                ans += str((int(s[i]) + int(s[i + 1])) % 10)
            s = ans
            ans = ''
            print(s)
        return s[0] == s[1]

Given a string s, calculate its reverse degree.

The reverse degree is calculated as follows:

For each character, multiply its position in the reversed alphabet ('a' = 26, 'b' = 25, ..., 'z' = 1) with its position in the string (1-indexed).
Sum these products for all characters in the string.
Return the reverse degree of s.

class Solution:
    def reverseDegree(self, s: str) -> int:
        ans = 0
        d = {'a' : 26, 'b' : 25, 'c' : 24, 'd' : 23, 'e' : 22, 'f' : 21, 'g' : 20, 'h' : 19, 'i' : 18, 'j' : 17, 'k' : 16, 'l' : 15, 'm' : 14, 'n' : 13, 'o' : 12, 'p' : 11, 'q' : 10, 'r' : 9, 's' : 8, 't' : 7, 'u' : 6, 'v' : 5, 'w' : 4, 'x' : 3, 'y' : 2, 'z' : 1}
        for i in range(len(s)):
            ans += d[s[i]] * (i + 1)
        return ans

You are given an integer array nums and an integer k.

An integer h is called valid if all values in the array that are strictly greater than h are identical.

For example, if nums = [10, 8, 10, 8], a valid integer is h = 9 because all nums[i] > 9 are equal to 10, but 5 is not a valid integer.

You are allowed to perform the following operation on nums:

Select an integer h that is valid for the current values in nums.
For each index i where nums[i] > h, set nums[i] to h.
Return the minimum number of operations required to make every element in nums equal to k. If it is impossible to make all elements equal to k, return -1.

class Solution:
    def minOperations(self, nums: List[int], k: int) -> int:
        lst = []
        for element in nums:
            if element not in lst:
                lst.append(element)
        lst = sorted(lst)
        if k > min(lst):
            return -1
        for i in range(len(lst)):
            if lst[0] > k:
                return len(lst)
            if lst[i] == k:
                return len(lst) - i - 1

You are given an integer array cost of size n. You are currently at position n (at the end of the line) in a line of n + 1 people (numbered from 0 to n).

You wish to move forward in the line, but each person in front of you charges a specific amount to swap places. The cost to swap with person i is given by cost[i].

You are allowed to swap places with people as follows:

If they are in front of you, you must pay them cost[i] to swap with them.
If they are behind you, they can swap with you for free.
Return an array answer of size n, where answer[i] is the minimum total cost to reach each position i in the line.

class Solution:
    def minCosts(self, cost: List[int]) -> List[int]:
        ans = [cost[0]]
        for i in range(1, len(cost)):
            ans.append(min(cost[:i + 1]))
        return ans

You are given an integer array nums and an integer k. You can perform the following operation any number of times:

Select an index i and replace nums[i] with nums[i] - 1.
Return the minimum number of operations required to make the sum of the array divisible by k.

class Solution:
    def minOperations(self, nums: List[int], k: int) -> int:
        return sum(nums) % k

Given a circular array nums, find the maximum absolute difference between adjacent elements.

Note: In a circular array, the first and last elements are adjacent.

class Solution:
    def maxAdjacentDistance(self, nums: List[int]) -> int:
        lst = []
        for i in range(len(nums) - 1):
            lst.append(abs(nums[i] - nums[i + 1]))
        lst.append(abs(nums[0] - nums[len(nums) - 1]))
        return max(lst)

You are given three integers x, y, and z, representing the positions of three people on a number line:

x is the position of Person 1.
y is the position of Person 2.
z is the position of Person 3, who does not move.
Both Person 1 and Person 2 move toward Person 3 at the same speed.

Determine which person reaches Person 3 first:

Return 1 if Person 1 arrives first.
Return 2 if Person 2 arrives first.
Return 0 if both arrive at the same time.
Return the result accordingly.

class Solution:
    def findClosest(self, x: int, y: int, z: int) -> int:
        if abs(x - z) > abs(y - z):
            return 2
        elif abs(x - z) < abs(y - z):
            return 1
        else:
            return 0

You are given a string s consisting of lowercase English letters ('a' to 'z').

Your task is to:

Find the vowel (one of 'a', 'e', 'i', 'o', or 'u') with the maximum frequency.
Find the consonant (all other letters excluding vowels) with the maximum frequency.
Return the sum of the two frequencies.

Note: If multiple vowels or consonants have the same maximum frequency, you may choose any one of them. If there are no vowels or no consonants in the string, consider their frequency as 0.

The frequency of a letter x is the number of times it occurs in the string.

class Solution:
    def maxFreqSum(self, s: str) -> int:
        d_vowel = {}
        d_consonant = {}
        vowel = ['a', 'e', 'i', 'o', 'u']
        consonant = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z']
        for i in range(len(s)):
            if s[i] in vowel and s[i] not in d_vowel.keys():
                d_vowel[s[i]] = 1
            elif s[i] in vowel and s[i] in d_vowel.keys():
                d_vowel[s[i]] += 1
            elif s[i] in consonant and s[i] not in d_consonant.keys():
                d_consonant[s[i]] = 1
            else:
                d_consonant[s[i]] += 1
        if not list(d_vowel.values()):
            return max(list(d_consonant.values())) 
        elif not list(d_consonant.values()):
            return max(list(d_vowel.values()))
        else:
            return max(list(d_vowel.values())) + max(list(d_consonant.values()))

You are given a string s consisting of lowercase English letters, and an integer k.

Your task is to delete some (possibly none) of the characters in the string so that the number of distinct characters in the resulting string is at most k.

Return the minimum number of deletions required to achieve this.

class Solution:
    def minDeletion(self, s: str, k: int) -> int:
        d = {}
        ans = 0
        for i in range(len(s)):
            if s[i] not in d.keys():
                d[s[i]] = 1
            else:
                d[s[i]] += 1
        count = 0
        lst = []
        for i in range(len(s)):
            if s[i] not in lst:
                count += 1
                lst.append(s[i])
        print(count)
        while count > k:
            d = dict(sorted(d.items(), key = lambda item: item[1]))
            d[list(d.keys())[0]] -= 1
            ans += 1
            if d[list(d.keys())[0]] == 0:
                d.pop(list(d.keys())[0])
                count -= 1
        print(count)
        return ans

You are given an integer array nums.

Return the smallest index i such that the sum of the digits of nums[i] is equal to i.

If no such index exists, return -1.

class Solution:
    def smallestIndex(self, nums: List[int]) -> int:
        s = 0
        for i in range(len(nums)):
            for j in range(len(str(nums[i]))):
                s += int(str(nums[i])[j])
            if s == i:
                return i
            s = 0
        return -1

There is a circle of red and blue tiles. You are given an array of integers colors. The color of tile i is represented by colors[i]:

colors[i] == 0 means that tile i is red.
colors[i] == 1 means that tile i is blue.
Every 3 contiguous tiles in the circle with alternating colors (the middle tile has a different color from its left and right tiles) is called an alternating group.

Return the number of alternating groups.

Note that since colors represents a circle, the first and the last tiles are considered to be next to each other.

class Solution:
    def numberOfAlternatingGroups(self, colors: List[int]) -> int:
        count = 0
        for i in range(len(colors)):
            if i == len(colors) - 2:
                if colors[i] != colors[i + 1] and colors[i + 1] != colors[0]:
                    count += 1
            if i == len(colors) - 1:
                if colors[i] != colors[0] and colors[0] != colors[1]:
                    count += 1
            if i < len(colors) - 2:
                if colors[i] != colors[i + 1] and colors[i + 1] != colors[i + 2]:
                    count += 1
        return count

You are given a 0-indexed integer array nums of even length and there is also an empty array arr. Alice and Bob decided to play a game where in every round Alice and Bob will do one move. The rules of the game are as follows:

Every round, first Alice will remove the minimum element from nums, and then Bob does the same.
Now, first Bob will append the removed element in the array arr, and then Alice does the same.
The game continues until nums becomes empty.
Return the resulting array arr.

class Solution:
    def numberGame(self, nums: List[int]) -> List[int]:
        lst = []
        nums = sorted(nums)
        while nums:
            lst.append(nums[1])
            lst.append(nums[0])
            nums = nums[2:]
        return lst

An integer divisible by the sum of its digits is said to be a Harshad number. You are given an integer x. Return the sum of the digits of x if x is a Harshad number, otherwise, return -1.

class Solution:
    def sumOfTheDigitsOfHarshadNumber(self, x: int) -> int:
        s = 0
        for i in range(len(str(x))):
            s += int(str(x)[i])
        if x % s == 0:
            return s
        else:
            return -1

You are given a 2D integer array tasks where tasks[i] = [si, ti].

Each [si, ti] in tasks represents a task with start time si that takes ti units of time to finish.

Return the earliest time at which at least one task is finished.

class Solution:
    def earliestTime(self, tasks: List[List[int]]) -> int:
        lst = []
        for element in tasks:
            lst.append(element[0] + element[1])
        return min(lst)

Given an integer n, find the digit that occurs least frequently in its decimal representation. If multiple digits have the same frequency, choose the smallest digit.

Return the chosen digit as an integer.

The frequency of a digit x is the number of times it appears in the decimal representation of n.

class Solution:
    def getLeastFrequentDigit(self, n: int) -> int:
        d = {}
        for i in range(len(str(n))):
            if str(n)[i] not in d.keys():
                d[str(n)[i]] = 1
            else:
                d[str(n)[i]] += 1
        d = dict(sorted(d.items(), key = lambda item: item[0]))
        d = dict(sorted(d.items(), key = lambda item: item[1]))
        return int(list(d.keys())[0])

You are given a positive integer n.

Return the maximum product of any two digits in n.

Note: You may use the same digit twice if it appears more than once in n.

class Solution:
    def maxProduct(self, n: int) -> int:
        lst = []
        for i in range(len(str(n))):
            lst.append(str(n)[i])
        lst = sorted(lst)
        return int(lst[len(lst) - 1]) * int(lst[len(lst) - 2])

You are given a 0-indexed string s typed by a user. Changing a key is defined as using a key different from the last used key. For example, s = "ab" has a change of a key while s = "bBBb" does not have any.

Return the number of times the user had to change the key.

Note: Modifiers like shift or caps lock won't be counted in changing the key that is if a user typed the letter 'a' and then the letter 'A' then it will not be considered as a changing of key.

class Solution:
    def countKeyChanges(self, s: str) -> int:
        lower = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
        upper = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']
        count = 0
        while len(s) > 1:
            if s[0] in lower:
                if s[1] == upper[lower.index(s[0])] or s[1] == s[0]:
                    s = s[1:]
                else:
                    count += 1
                    s = s[1:]
            else:
                if s[1] == lower[upper.index(s[0])] or s[1] == s[0]:
                    s = s[1:]
                else:
                    count += 1
                    s = s[1:]
        return count

You are given a positive integer n. Determine whether n is divisible by the sum of the following two values:

The digit sum of n (the sum of its digits).

The digit product of n (the product of its digits).

Return true if n is divisible by this sum; otherwise, return false.

class Solution:
    def checkDivisibility(self, n: int) -> bool:
        s = 0
        p = 1
        for i in range(len(str(n))):
            s += int(str(n)[i])
            p = p * int(str(n)[i])
        return n % (s + p) == 0

You are given a positive integer n representing an n x n cargo deck on a ship. Each cell on the deck can hold one container with a weight of exactly w.

However, the total weight of all containers, if loaded onto the deck, must not exceed the ship's maximum weight capacity, maxWeight.

Return the maximum number of containers that can be loaded onto the ship.

class Solution:
    def maxContainers(self, n: int, w: int, maxWeight: int) -> int:
        if n ** 2 * w < maxWeight:
            return n ** 2
        else:
            return maxWeight // w

An ant is on a boundary. It sometimes goes left and sometimes right.

You are given an array of non-zero integers nums. The ant starts reading nums from the first element of it to its end. At each step, it moves according to the value of the current element:

If nums[i] < 0, it moves left by -nums[i] units.
If nums[i] > 0, it moves right by nums[i] units.
Return the number of times the ant returns to the boundary.

Notes:

There is an infinite space on both sides of the boundary.
We check whether the ant is on the boundary only after it has moved |nums[i]| units. In other words, if the ant crosses the boundary during its movement, it does not count.

class Solution:
    def returnToBoundaryCount(self, nums: List[int]) -> int:
        ants = 0
        count = 0
        for element in nums:
            ants += element
            if ants == 0:
                count += 1
        return count

You are given an integer array nums.

The alternating sum of nums is the value obtained by adding elements at even indices and subtracting elements at odd indices. That is, nums[0] - nums[1] + nums[2] - nums[3]...

Return an integer denoting the alternating sum of nums.

class Solution:
    def alternatingSum(self, nums: List[int]) -> int:
        s = 0
        for i in range(len(nums)):
            if i % 2 == 0:
                s += nums[i]
            else:
                s -= nums[i]
        return s

You are given a positive integer n.

A positive integer is a base-10 component if it is the product of a single digit from 1 to 9 and a non-negative power of 10. For example, 500, 30, and 7 are base-10 components, while 537, 102, and 11 are not.

Express n as a sum of only base-10 components, using the fewest base-10 components possible.

Return an array containing these base-10 components in descending order.

class Solution:
    def decimalRepresentation(self, n: int) -> List[int]:
        lst = []
        while n:
            if str(n)[0] != '0':
                lst.append(int(str(n)[0] + '0' * (len(str(n)) - 1)))
            n = str(n)[1:]
        return lst

You are given a 0-indexed integer array nums, and an integer k.

In one operation, you can remove one occurrence of the smallest element of nums.

Return the minimum number of operations needed so that all elements of the array are greater than or equal to k.

class Solution:
    def minOperations(self, nums: List[int], k: int) -> int:
        n = len(nums)
        while min(nums) < k:
            nums.remove(min(nums))
        return n - len(nums)

You are given positive integers n and m.

Define two integers as follows:

num1: The sum of all integers in the range [1, n] (both inclusive) that are not divisible by m.
num2: The sum of all integers in the range [1, n] (both inclusive) that are divisible by m.
Return the integer num1 - num2.

class Solution:
    def differenceOfSums(self, n: int, m: int) -> int:
        num1 = 0
        num2 = 0
        for i in range(n + 1):
            if i % m == 0:
                num2 += i
            else:
                num1 += i
        return num1 - num2

You are given an integer array nums and an integer k.

Return an integer denoting the sum of all elements in nums whose frequency is divisible by k, or 0 if there are no such elements.

Note: An element is included in the sum exactly as many times as it appears in the array if its total frequency is divisible by k.

class Solution:
    def sumDivisibleByK(self, nums: List[int], k: int) -> int:
        d = {}
        s = 0
        for element in nums:
            if element not in d.keys():
                d[element] = 1
            else:
                d[element] += 1
        for element in nums:
            if d[element] % k == 0:
                s += element
        return s

You are given an integer array nums of size n. For each index i where 0 <= i < n, define a subarray nums[start ... i] where start = max(0, i - nums[i]).

Return the total sum of all elements from the subarray defined for each index in the array.

class Solution:
    def subarraySum(self, nums: List[int]) -> int:
        s = 0
        for i in range(len(nums)):
            s += sum(nums[max(0, i - nums[i]): i + 1])
        return s

You are given an array nums consisting of positive integers.

Return the total frequencies of elements in nums such that those elements all have the maximum frequency.

The frequency of an element is the number of occurrences of that element in the array.

class Solution:
    def maxFrequencyElements(self, nums: List[int]) -> int:
        d = {}
        for element in nums:
            if element not in d.keys():
                d[element] = 1
            else:
                d[element] += 1
        coef = 0
        for element in d.keys():
            if d[element] == max(d.values()):
                coef += 1
        return coef * max(d.values())

You are given a 0-indexed integer array nums and a target element target.

A target index is an index i such that nums[i] == target.

Return a list of the target indices of nums after sorting nums in non-decreasing order. If there are no target indices, return an empty list. The returned list must be sorted in increasing order.

class Solution:
    def targetIndices(self, nums: List[int], target: int) -> List[int]:
        nums = sorted(nums)
        ans = []
        for i in range(len(nums)):
            if nums[i] == target:
                ans.append(i)
        return ans

There are n rings and each ring is either red, green, or blue. The rings are distributed across ten rods labeled from 0 to 9.

You are given a string rings of length 2n that describes the n rings that are placed onto the rods. Every two characters in rings forms a color-position pair that is used to describe each ring where:

The first character of the ith pair denotes the ith ring's color ('R', 'G', 'B').
The second character of the ith pair denotes the rod that the ith ring is placed on ('0' to '9').
For example, "R3G2B1" describes n == 3 rings: a red ring placed onto the rod labeled 3, a green ring placed onto the rod labeled 2, and a blue ring placed onto the rod labeled 1.

Return the number of rods that have all three colors of rings on them.

class Solution:
    def countPoints(self, rings: str) -> int:
        lst = []
        d = {}
        for i in range(0, len(rings), 2):
            if rings[i:i + 2] not in lst:
                lst.append(rings[i:i + 2])
        for element in lst:
            if element[1] not in d.keys():
                d[element[1]] = 1
            else:
                d[element[1]] += 1
        count = 0
        for element in d.keys():
            if d[element] == 3:
                count += 1
        return count

You are given a 0-indexed array of strings words and a character x.

Return an array of indices representing the words that contain the character x.

Note that the returned array may be in any order.

class Solution:
    def findWordsContaining(self, words: List[str], x: str) -> List[int]:
        lst = []
        for i in range(len(words)):
            if x in words[i]:
                lst.append(i)
        return lst

You are given an integer array nums containing positive integers. We define a function encrypt such that encrypt(x) replaces every digit in x with the largest digit in x. For example, encrypt(523) = 555 and encrypt(213) = 333.

Return the sum of encrypted elements.

class Solution:
    def sumOfEncryptedInt(self, nums: List[int]) -> int:
        add = 0
        s = 0
        for element in nums:
            for i in range(len(str(element))):
                if int(str(element)[i]) > add:
                    add = int(str(element)[i])
            s += int(str(add) * len(str(element)))
            add = 0
        return s
