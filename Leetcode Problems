Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.

class Solution(object):
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        d={target-n:i for i,n in enumerate(nums)}
        for i in range(0,len(nums)-1):
            if nums[i] in d and i!=d[nums[i]]:
                return [i,d[nums[i]]]

Given an integer x, return true if x is a 
palindrome
, and false otherwise.

class Solution(object):
    def isPalindrome(self, x):
        """
        :type x: int
        :rtype: bool
        """
        if x<0:
            return False
        lst=[]
        while x!=0:
            digit=x%10
            lst.append(digit)
            x=x//10
        if lst==list(reversed(lst)):
            return True
        else:
            return False

Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9. 
X can be placed before L (50) and C (100) to make 40 and 90. 
C can be placed before D (500) and M (1000) to make 400 and 900.
Given a roman numeral, convert it to an integer.

class Solution(object):

    def romanToInt(self, s):
        """
        :type s: str
        :rtype: int
        """
        def string_sub(s, symbol):
            if s.endswith(symbol):
                return s[:-(len(symbol))]
            return s
        ans=0
        string=''
        value=[1,4,5,9,10,40,50,90,100,400,500,900,1000]
        three_symbol_nums = {
            "III": 3, "XXX": 30, ...
        }
        two_symbol_nums = {
            ...
        }
        one_sym


        symbol=['I','IV','V','IX','X','XL','L','XC','C','CD','D','CM','M']
        d={symbol[i]:value[i] for i in range(len(symbol))}
        for element in symbol:
            for i in [3, 2, 1]:
                print(element*i, s, ans)
                if s.endswith(element*i):
                    ans+=d[element]*i
                    s=string_sub(s,element*i)
        return ans

Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string "".

class Solution(object):
    def longestCommonPrefix(self, strs):
        """
        :type strs: List[str]
        :rtype: str
        """
        ans=''
        i=0
        if len(strs)>1:
            while i<min([len(element) for element in strs]):
                print(i)
                lst=[]
                j=0
                for string in strs:
                    if string!='':
                        lst.append(string[i])
                    else:
                        return ''
                while j+1 <len(lst):
                    print(j)
                    if lst[j]==lst[j+1]:
                        j+=1
                    else:
                        return ans
                if j==len(lst)-1:
                    ans+=lst[j]
                i+=1
            return ans
        else:
            return strs[0]

Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Every close bracket has a corresponding open bracket of the same type.

class Solution(object):
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """
        if s == '':
            return True
        if len(s) % 2 != 0:
            return False
        new_str = s.replace('()', '').replace('[]', '').replace('{}', '')
        if new_str == s:
            return False
        return self.isValid(new_str)

You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.

Merge nums1 and nums2 into a single array sorted in non-decreasing order.

The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.

class Solution(object):
    def merge(self, nums1, m, nums2, n):
        """
        :type nums1: List[int]
        :type m: int
        :type nums2: List[int]
        :type n: int
        :rtype: None Do not return anything, modify nums1 in-place instead.
        """
        for i in range(len(nums1)):
            if i>=m:
                nums1[i]=nums2[i-m]
        nums1=nums1.sort()

Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.

Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things:

Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.
Return k.

class Solution(object):
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        lst=[]
        i=0
        while i in range(len(nums)):
            if nums[i] in lst:
                nums.pop(i)
                i=i-1
            lst.append(nums[i])
            i+=1
        return len(nums)

Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.

Consider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:

Change the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums.
Return k.

class Solution(object):
    def removeElement(self, nums, val):
        """
        :type nums: List[int]
        :type val: int
        :rtype: int
        """
        i=0
        while i in range(len(nums)):
            if nums[i]==val:
                nums.pop(i)
                i=i-1
            i+=1
        return len(nums)

Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

class Solution(object):
    def strStr(self, haystack, needle):
        """
        :type haystack: str
        :type needle: str
        :rtype: int
        """
        if needle in haystack:
            i=0
            j=0
            empty_string=''
            while i<=len(haystack)-len(needle):
                print(i)
                j=i
                while j in range(i,len(needle)+i):
                    print(j)
                    empty_string+=haystack[j]
                    j+=1
                if empty_string==needle:
                    return i
                i+=1
                empty_string=''
        else:
            return -1

Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You must write an algorithm with O(log n) runtime complexity.

class Solution(object):
    def searchInsert(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        return self.helper(nums, target, 0)

    def helper(self, nums, target, nums_start_index):
        if len(nums) == 0:
            return nums_start_index
        middle_index = len(nums) // 2
        if nums[middle_index] == target:
            return middle_index + nums_start_index
        if nums[middle_index] > target:
            nums = nums[:middle_index]
            return self.helper(nums, target, nums_start_index)
        if nums[middle_index] < target:
            nums = nums[middle_index+1:]
            next_num_start_index = nums_start_index + middle_index + 1
            return self.helper(nums, target, next_num_start_index)

Given a string s consisting of words and spaces, return the length of the last word in the string.

A word is a maximal 
substring
 consisting of non-space characters only.

class Solution(object):
    def lengthOfLastWord(self, s):
        """
        :type s: str
        :rtype: int
        """
        alphabet=['A','a','B','b','C','c','D','d','E','e','F','f','G','g','H','h','I','i','J','j','K','k','L','l','M','m','N','n','O','o','P','p','Q','q','R','r','S','s','T','t','U','u','V','v','W','w','X','x','Y','y','Z','z']
        count=0
        while s.endswith(' '):
            s=s[:len(s)-1]
            print(s)
        for i in range(len(s)):
            if s[i] not in alphabet:
                count=0
            else:
                count+=1
        return count

You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.

Increment the large integer by one and return the resulting array of digits.

class Solution(object):
    def plusOne(self, digits):
        """
        :type digits: List[int]
        :rtype: List[int]
        """
        empty_string=''
        for element in digits:
            empty_string+=str(element)
        integer=int(empty_string)
        integer+=1
        string=str(integer)
        lst=[]
        for i in range(len(string)):
            lst.append(int(string[i]))
        return lst

Given a 0-indexed integer array nums of length n and an integer target, return the number of pairs (i, j) where 0 <= i < j < n and nums[i] + nums[j] < target.

class Solution(object):
    def countPairs(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        count = 0
        nums = sorted(nums)
        for i in range(len(nums) - 1):
            rest = nums[i+1:]
            middle_index = len(rest) // 2
            while len(rest) != 0:
                if nums[i] + rest[middle_index] >= target: 
                    rest = rest[:middle_index]
                    middle_index = len(rest) // 2
                else:
                    count += middle_index + 1
                    rest = rest[middle_index + 1:] 
                    middle_index = len(rest) // 2
        return count

Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.

class Solution(object):
    def countNegatives(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        lst = []
        m = len(grid)
        n = len(grid[0])
        i = m - 1
        j = 0
        count = 0
        while i >= 0 and j < n:
            if grid[i][j] >= 0:
                j += 1
            else:
                count += n - j
                i -= 1
        return count

You are given a 0-indexed integer array nums and a target element target.

A target index is an index i such that nums[i] == target.

Return a list of the target indices of nums after sorting nums in non-decreasing order. If there are no target indices, return an empty list. The returned list must be sorted in increasing order.

class Solution(object):
    def targetIndices(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        nums = sorted(nums)
        return sorted(self.helper(nums, target, 0))

    def helper(self, nums, target, start_index):
        if len(nums) == 0:
            return []
        middle_index = len(nums) // 2
        if nums[middle_index] == target:
            return [middle_index + start_index] + self.helper(nums[:middle_index], target, start_index) + self.helper(nums[middle_index + 1:], target, start_index + middle_index + 1)
        if nums[middle_index] > target:
            return self.helper(nums[:middle_index], target, start_index)
        if nums[middle_index] < target:
            return self.helper(nums[middle_index + 1:], target, start_index + middle_index + 1)

Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.

You must not use any built-in exponent function or operator.

For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.

class Solution(object):
    def mySqrt(self, x):
        """
        :type x: int
        :rtype: int
        """

        return self.helper(x, 0, x)

    def helper(self, upper, lower, x):
        mid_point = upper - (upper - lower) // 2
        if mid_point * mid_point < x:
            if (mid_point + 1) * (mid_point + 1) > x:
                return mid_point
            lower = mid_point
            return self.helper(upper, lower, x)
        if mid_point * mid_point == x:
            return mid_point
        if mid_point * mid_point > x:
            if (mid_point - 1) * (mid_point - 1) < x:
                return mid_point - 1
            upper = mid_point
            return self.helper(upper, lower, x)

Given two binary strings a and b, return their sum as a binary string.

class Solution(object):
    def addBinary(self, a, b):
        """
        :type a: str
        :type b: str
        :rtype: str
        """
        int_a = int(a)
        int_b = int(b)
        res = int_a + int_b
        count = 0
        coefficient = 10 ** count
        divisor = 10 
        ans = 2
        digit = len(str(res))
        while count <= digit:
            print(res)
            if str(res % divisor).startswith('6'):
                res -= 5 * coefficient
                if count < digit:
                    res += 2 * coefficient * 10
            if str(res % divisor).startswith('5'):
                res -= 4 * coefficient
                if count < digit:
                    res += 2 * coefficient * 10
            if str(res % divisor).startswith('4'):
                res -= 3 * coefficient
                if count < digit:
                    res +=  coefficient * 10
            if str(res % divisor).startswith('3'):
                res -= 2 * coefficient
                if count < digit:
                    res += coefficient * 10
            if str(res % divisor).startswith('2'):
                res += 8 * coefficient
                count += 1
                coefficient = 10 ** count
                divisor *= 10
            else:    
                count += 1
                coefficient = 10 ** count
                divisor *= 10
        res = str(res)
        return res

Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.

# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def deleteDuplicates(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if head is None:
            return None
        lst = [head.val]
        res = cur = ListNode(head.val)
        while head:
            print(lst)
            if head.val not in lst:
                lst.append(head.val)
                cur.next = head
                cur = cur.next
            if head.next is None:
                cur.next = None
            head = head.next
        return res

Given two integer arrays nums1 and nums2, return an array of their 
intersection
. Each element in the result must be unique and you may return the result in any order.

class Solution(object):
    def intersection(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """
        lst = []
        for element in nums1:
            if element in nums2:
                if element not in lst:
                    lst.append(element)
        return lst

You are climbing a staircase. It takes n steps to reach the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

class Solution(object):
    def climbStairs(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n == 1:
            return 1
        if n == 2:
            return 2
        return self.climbStairs(n - 1) + self.climbStairs(n - 2)

You are given an m x n binary matrix mat of 1's (representing soldiers) and 0's (representing civilians). The soldiers are positioned in front of the civilians. That is, all the 1's will appear to the left of all the 0's in each row.

A row i is weaker than a row j if one of the following is true:

The number of soldiers in row i is less than the number of soldiers in row j.
Both rows have the same number of soldiers and i < j.
Return the indices of the k weakest rows in the matrix ordered from weakest to strongest.

class Solution(object):
    def kWeakestRows(self, mat, k):
        """
        :type mat: List[List[int]]
        :type k: int
        :rtype: List[int]
        """
        m = len(mat)
        if m == 0:
            return []
        n = len(mat[0])
        counts = []
        for i in range(m):
            row = mat[i]
            count = 0
            start_index = 0
            end_index = n - 1
            while start_index <= end_index:
                middle_index = (start_index + end_index) // 2
                if row[middle_index] == 0:
                    end_index = middle_index - 1
                else:
                    if (end_index - start_index + 1) % 2 == 0:
                        count += (end_index - start_index + 1) // 2
                    else:
                        count += (end_index - start_index + 1) // 2 + 1
                    start_index = middle_index + 1
            counts.append((i, count))
        counts = sorted(counts, key=lambda x: (x[1], x[0]))
        return [i for i, _ in counts[:k]]

You are given an integer array nums of length n, and an integer array queries of length m.

Return an array answer of length m where answer[i] is the maximum size of a subsequence that you can take from nums such that the sum of its elements is less than or equal to queries[i].

A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.

class Solution(object):
    def answerQueries(self, nums, queries):
        """
        :type nums: List[int]
        :type queries: List[int]
        :rtype: List[int]
        """
        m = len(nums)
        n = len(queries)
        lst = []
        nums = sorted(nums) O(mlogm)
        for query in queries: O(n)
            lst += [self.helper(nums, len(nums) - 1, 0, query)] O(logm)
        return lst

    def helper(self, nums, upper, lower, query):
            middle_index = (upper + lower) // 2
            if upper < lower:
                return middle_index + 1
            if sum(nums[:middle_index + 1]) > query:
                return self.helper(nums, middle_index - 1, lower, query)
            elif sum(nums[:middle_index + 1]) == query:
                return middle_index + 1
            else:
                return self.helper(nums, upper, middle_index + 1, query)

Given an array nums sorted in non-decreasing order, return the maximum between the number of positive integers and the number of negative integers.

In other words, if the number of positive integers in nums is pos and the number of negative integers is neg, then return the maximum of pos and neg.
Note that 0 is neither positive nor negative.

class Solution(object):
    def maximumCount(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        pos_index = self.find_smallest_positive_index(len(nums) - 1, 0, nums)
        pos = len(nums) - pos_index
        neg = self.find_largest_negative_index(len(nums[:pos_index]) - 1, 0, nums[:pos_index])
        return pos if pos > neg else neg

        
    def find_smallest_positive_index(self, upper, lower, nums):
        middle_index = (upper + lower) // 2
        if upper < lower:
            return middle_index + 1
        if nums[middle_index] > 0:
            return self.find_smallest_positive_index(middle_index - 1, lower, nums)
        else:
            return self.find_smallest_positive_index(upper, middle_index + 1, nums)

    def find_largest_negative_index(self, upper, lower, nums):
        middle_index = (upper + lower) // 2
        if upper < lower:
            return middle_index + 1
        if nums[middle_index] >= 0:
            return self.find_largest_negative_index(middle_index - 1, lower, nums)
        else:
            return self.find_largest_negative_index(upper, middle_index + 1, nums)

Given two integer arrays arr1 and arr2, and the integer d, return the distance value between the two arrays.

The distance value is defined as the number of elements arr1[i] such that there is not any element arr2[j] where |arr1[i]-arr2[j]| <= d.

class Solution(object):
    def findTheDistanceValue(self, arr1, arr2, d):
        """
        :type arr1: List[int]
        :type arr2: List[int]
        :type d: int
        :rtype: int
        """
        res = 0
        arr2 = sorted(arr2)
        for arr1_elem in arr1:
            res += self.find_closest_element(arr1_elem, arr2, len(arr2) - 1, 0, d)
        return res
                
    def find_closest_element(self, arr1_elem, arr2, upper, lower, d):
        middle_index = (upper + lower) // 2
        if upper < lower:
            return 1
        if abs(arr1_elem - arr2[middle_index]) <= d:
            return 0
        if arr1_elem - arr2[middle_index] > 0:
            return self.find_closest_element(arr1_elem, arr2, upper, middle_index + 1, d)
        elif arr1_elem - arr2[middle_index] < 0:
            return self.find_closest_element(arr1_elem, arr2, middle_index - 1, lower, d)
        else:
            return 0

Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.

class Solution(object):
    def missingNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        nums = sorted(nums)
        if nums[0] != 0:
            return 0
        if nums[len(nums) - 1] != len(nums):
            return len(nums)
        return self.find_missing_number(nums, len(nums) - 1, 0)
    
    def find_missing_number(self, nums, upper, lower):
        middle_index = (upper + lower) // 2
        if upper < lower:
            return nums[middle_index] - 1
        if nums[middle_index] - nums[middle_index - 1] == 2:
            return nums[middle_index] - 1
        if middle_index + 1 == nums[middle_index] + 1:
            return self.find_missing_number(nums, upper, middle_index + 1)
        else:
            return self.find_missing_number(nums, middle_index - 1, lower)

You are given an array nums of non-negative integers. nums is considered special if there exists a number x such that there are exactly x numbers in nums that are greater than or equal to x.

Notice that x does not have to be an element in nums.

Return x if the array is special, otherwise, return -1. It can be proven that if nums is special, the value for x is unique.

class Solution(object):
    def specialArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        nums = sorted(nums)
        return self.find_x(nums, len(nums) - 1, 0)
    
    def find_x(self, nums, upper, lower):
        middle_index = (upper + lower) // 2
        if upper < lower:
            return -1
        if nums[middle_index] >= len(nums) - middle_index:
            if middle_index == 0:
                return len(nums)
            if middle_index == nums[len(nums) - 1]:
                return -1
            if nums[middle_index - 1] < len(nums) - middle_index:
                return len(nums) - middle_index
            else:
                return self.find_x(nums, middle_index - 1, lower)
        else:
            return self.find_x(nums, upper, middle_index + 1)

Given an array arr of positive integers sorted in a strictly increasing order, and an integer k.

Return the kth positive integer that is missing from this array.

class Solution(object):
    def findKthPositive(self, arr, k):
        """
        :type arr: List[int]
        :type k: int
        :rtype: int
        """
        return self.find_right_element(arr, len(arr) - 1, 0, k)
        
    def find_right_element(self, arr, upper, lower, k):
        middle_index = (upper + lower) // 2
        if upper < lower:
            return k + middle_index + 1
        if k > arr[middle_index] - middle_index - 1:
            if middle_index >= len(arr) - 1:
                return k + middle_index + 1
            return self.find_right_element(arr, upper, middle_index + 1, k)
        else:
            if middle_index <= 0:
                return range(arr[0])[k]
            return self.find_right_element(arr, middle_index - 1, lower, k)

Given two integer arrays nums1 and nums2, sorted in non-decreasing order, return the minimum integer common to both arrays. If there is no common integer amongst nums1 and nums2, return -1.

Note that an integer is said to be common to nums1 and nums2 if both arrays have at least one occurrence of that integer.

class Solution(object):
    def getCommon(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: int
        """
        i = 0
        j = self.get_j_index(nums1, nums2, len(nums2) - 1, 0)
        while i < len(nums1) and j < len(nums2):
            if nums1[i] == nums2[j]:
                return nums1[i]
            elif nums1[i] < nums2[j]:
                i += 1
            else:
                j += 1
        return -1

    def get_j_index(self, nums1, nums2, upper, lower):
        middle_index = (upper + lower) // 2
        if middle_index <= 0:
            return 0
        if middle_index >= len(nums2) - 1:
            return len(nums2) - 1
        if upper < lower:
            return middle_index
        if nums1[0] > nums2[middle_index]:
            if nums1[0] < nums2[middle_index + 1]:
                return middle_index
            return self.get_j_index(nums1, nums2, upper, middle_index + 1)
        else:
            return self.get_j_index(nums1, nums2, middle_index - 1, lower)

Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.

You must write an algorithm with O(log n) runtime complexity.

class Solution(object):
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        return self.search_target(nums, len(nums) - 1, 0, target)
    
    def search_target(self, nums, upper, lower, target):
        middle_index = (upper + lower) // 2
        if upper < lower:
            return -1
        if nums[middle_index] == target:
            return middle_index
        elif nums[middle_index] > target:
            return self.search_target(nums, middle_index - 1, lower, target)
        else:
            return self.search_target(nums, upper, middle_index + 1, target)

Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.

class Solution(object):
    def find_nums_2_index(self, nums1_element, nums2, upper, lower):
        middle_index = (upper + lower) // 2
        if upper < lower:
            return None
        if nums2[middle_index] > nums1_element:
            return self.find_nums_2_index(nums1_element, nums2, middle_index - 1, lower)
        if nums2[middle_index] < nums1_element:
            return self.find_nums_2_index(nums1_element, nums2, upper, middle_index + 1)
        return middle_index

    def intersect(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """
        from collections import Counter

        nums1_counter = Counter(nums1)
        nums2_counter = Counter(nums2)
        final_counter = Counter([])
        for num, count in nums1_counter.items():
            if num in nums2_counter:
                final_counter[num] = min(count, nums2_counter[num])
        return [
            result
            for num, count in final_counter.items()
            for result in [num] * count
        ]
        # lst= []
        # nums2 = sorted(nums2)
        # nums2_remain = [n for n in nums2]
        # for nums1_element in nums1:
        #     index = self.find_nums_2_index(nums1_element, nums2_remain, len(nums2_remain) - 1, 0)
        #     if index is None:
        #         continue
        #     nums2_remain = nums2_remain[:index] + nums2_remain[index + 1:]
        #     lst.append(nums1_element)
        #     if len(nums2_remain) == 0:
        #         break
        # return lst

We are playing the Guess Game. The game is as follows:

I pick a number from 1 to n. You have to guess which number I picked.

Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.

You call a pre-defined API int guess(int num), which returns three possible results:

-1: Your guess is higher than the number I picked (i.e. num > pick).
1: Your guess is lower than the number I picked (i.e. num < pick).
0: your guess is equal to the number I picked (i.e. num == pick).
Return the number that I picked.

# The guess API is already defined for you.
# @param num, your guess
# @return -1 if num is higher than the picked number
#          1 if num is lower than the picked number
#          otherwise return 0
# def guess(num):

class Solution(object):
    def guessNumber(self, n):
        """
        :type n: int
        :rtype: int
        """
        return self.guessed_number(n - 1, 0)
        
    def guessed_number(self, upper, lower):
        middle_index = (upper + lower) // 2
        if guess(middle_index + 1) == 1:
            return self.guessed_number(upper, middle_index + 1)
        elif guess(middle_index + 1) == -1:
            return self.guessed_number(middle_index - 1, lower)
        else:
            return middle_index + 1

Alice and Bob have a different total number of candies. You are given two integer arrays aliceSizes and bobSizes where aliceSizes[i] is the number of candies of the ith box of candy that Alice has and bobSizes[j] is the number of candies of the jth box of candy that Bob has.

Since they are friends, they would like to exchange one candy box each so that after the exchange, they both have the same total amount of candy. The total amount of candy a person has is the sum of the number of candies in each box they have.

Return an integer array answer where answer[0] is the number of candies in the box that Alice must exchange, and answer[1] is the number of candies in the box that Bob must exchange. If there are multiple answers, you may return any one of them. It is guaranteed that at least one answer exists.

class Solution(object):
    def fairCandySwap(self, aliceSizes, bobSizes):
        """
        :type aliceSizes: List[int]
        :type bobSizes: List[int]
        :rtype: List[int]
        """
        def find_target(bobSizes, target, upper, lower):
            middle_index = (upper + lower) // 2
            if upper < lower:
                return False
            if bobSizes[middle_index] > target:
                return find_target(bobSizes, target, middle_index - 1, lower)
            if bobSizes[middle_index] < target:
                return find_target(bobSizes, target, upper, middle_index + 1)
            return True
            
        bobSizes = sorted(bobSizes)
        aliceSizesSum = sum(aliceSizes)
        bobSizesSum = sum(bobSizes)
        diff = aliceSizesSum - bobSizesSum
        for aliceSizesElement in aliceSizes:
            target = aliceSizesElement - diff // 2
            found = find_target(bobSizes, target, len(bobSizes) - 1, 0)
            if found:
                return [aliceSizesElement, target]

Given the root of a complete binary tree, return the number of the nodes in the tree.

According to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.

Design an algorithm that runs in less than O(n) time complexity.

# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def countNodes(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if root is None:
            return 0
        if root.right is None and root.left is None:
            return 1
        def count_depth(root):
            if root is None:
                return 0
            return count_depth(root.left) + 1
            
        def return_nodes(root, depth):
            if depth == 0:
                return [root]
            return return_nodes(root.left, depth - 1) + return_nodes(root.right, depth - 1)

        def count_bottom_nodes(node_list, upper, lower):
            middle_index = (upper + lower) // 2
            if upper < lower:
                return middle_index * 2 + 2
            if node_list[middle_index].left is None:
                return count_bottom_nodes(node_list, middle_index - 1, lower)
            if node_list[middle_index].right is None:
                return middle_index * 2 + 1
            return count_bottom_nodes(node_list, upper, middle_index + 1)
        
        depth = count_depth(root)

        node_list = return_nodes(root, depth - 2)

        return 2 ** (depth - 1) - 1 + count_bottom_nodes(node_list, 2 ** (depth - 2) - 1, 0)

You are given an array of characters letters that is sorted in non-decreasing order, and a character target. There are at least two different characters in letters.

Return the smallest character in letters that is lexicographically greater than target. If such a character does not exist, return the first character in letters.

class Solution(object):
    def nextGreatestLetter(self, letters, target):
        """
        :type letters: List[str]
        :type target: str
        :rtype: str
        """

        def find_smallest_letter(upper, lower):
            middle_index = (upper + lower) // 2
            if upper < lower:
                if middle_index >= len(letters) - 1:
                    return letters[0]
                return letters[middle_index + 1]
            if letters[middle_index] > target:
                return find_smallest_letter(middle_index - 1, lower)
            if letters[middle_index] <= target:
                return find_smallest_letter(upper, middle_index + 1)
            
        return find_smallest_letter(len(letters) - 1, 0)

You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.

Given the integer n, return the number of complete rows of the staircase you will build.

class Solution(object):
    def arrangeCoins(self, n):
        """
        :type n: int
        :rtype: int
        """
        def find_level(upper, lower):
            middle = (upper + lower) // 2
            if upper < lower:
                return middle
            if middle * (1 + middle) / 2 < n:
                return find_level(upper, middle + 1)
            if middle * (1 + middle) // 2 > n:
                return find_level(middle - 1, lower)
            return middle

        return find_level(n, 0)

You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.

You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.

# The isBadVersion API is already defined for you.
# @param version, an integer
# @return a bool
# def isBadVersion(version):

class Solution(object):
    def firstBadVersion(self, n):
        """
        :type n: int
        :rtype: int
        """

        def find_first_bad(upper, lower):
            middle = (upper + lower) // 2
            if upper < lower:
                return middle + 1
            if isBadVersion(middle) == True:
                return find_first_bad(middle - 1, lower)
            if isBadVersion(middle) == False:
                return find_first_bad(upper, middle + 1)
        
        return find_first_bad(n, 1)

Given a positive integer num, return true if num is a perfect square or false otherwise.

A perfect square is an integer that is the square of an integer. In other words, it is the product of some integer with itself.

You must not use any built-in library function, such as sqrt.

class Solution(object):
    def isPerfectSquare(self, num):
        """
        :type num: int
        :rtype: bool
        """
        
        def find_square_root(upper, lower):
            middle = (upper + lower) // 2
            if upper < lower:
                return False
            if middle ** 2 < num:
                return find_square_root(upper, middle + 1)
            if middle ** 2 > num:
                return find_square_root(middle - 1, lower)
            return True

        return find_square_root(num, 0)

In the universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has n empty baskets, the ith basket is at position[i], Morty has m balls and needs to distribute the balls into the baskets such that the minimum magnetic force between any two balls is maximum.

Rick stated that magnetic force between two different balls at positions x and y is |x - y|.

Given the integer array position and the integer m. Return the required force.

class Solution(object):
    def maxDistance(self, position, m):
        """
        :type position: List[int]
        :type m: int
        :rtype: int
        """
        position = sorted(position)

        def find_minimum_ge_gap(gap, up, low):
            middle_index = (up + low) // 2
            # print(f"find_min_ge_gap: {middle_index=},{up=},{low=}, {gap=}")
            if low > len(position):
                return None
            if up < low:
                return low
            if position[middle_index] >= gap:
                return find_minimum_ge_gap(gap, middle_index - 1, low)
            return find_minimum_ge_gap(gap, up, middle_index + 1)
        
        
        def can_place_balls(i, gap, position, m):
            while m > 0:
                # print(f"can_place_balls: {i=},{gap=}")
                if i > len(position) - 1:
                    return False
                i = find_minimum_ge_gap(position[i] + gap, len(position) - 1, 1)
                if i is None:
                    return False
                m -= 1
            print('True')
            return True
        
        def find_gap(upper, lower):
            middle = (upper + lower) // 2
            # print(f"{upper=},{lower=},{middle=}")
            if upper < lower:
                return middle
            if can_place_balls(0, middle, position, m):
                return find_gap(upper, middle + 1)
            return find_gap(middle - 1, lower)
        
            
        # for gap in reversed(range(2, (position[-1])//(m - 1) + 1)):
        #     print(f"{gap=}")
        #     if can_place_balls(gap, position, m):
        #         return gap
        # return 1

        return find_gap((position[-1] - position[0]) // (m - 1), 2)

A conveyor belt has packages that must be shipped from one port to another within days days.

The ith package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.

Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within days days.

class Solution:
    def shipWithinDays(self, weights: List[int], days: int) -> int:
        max_cap = sum(weights)
        min_cap = max(weights)

        def days_required(cap):
            days = 1
            i = 0
            sum = 0
            while i < len(weights) - 1:
                sum += weights[i]
                if sum + weights[i + 1] > cap:
                    days += 1
                    sum = 0
                i += 1
            return days

        def find_capacity(upper, lower):
            middle = (upper + lower) // 2
            if upper < lower:
                return lower
            if days_required(middle) > days:
                return find_capacity(upper, middle + 1)
            return find_capacity(middle - 1, lower)
        
        return find_capacity(max_cap, min_cap)

Write an algorithm to determine if a number n is happy.

A happy number is a number defined by the following process:

Starting with any positive integer, replace the number by the sum of the squares of its digits.
Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.
Those numbers for which this process ends in 1 are happy.
Return true if n is a happy number, and false if not.

class Solution:
    def isHappy(self, n: int) -> bool:
        res = 0
        lst = []
        while n != 1:
            for i in range(len(str(n))):
                res += (int(str(n)[i])) ** 2
            print(f"{res=}")
            n = res
            if n in lst:
                return False
            lst.append(n)
            res = 0
        return True

Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        if head is None:
            return None
        lst = []
        while head:
            if head.val != val:
                lst.append(head.val)
            head = head.next
        if len(lst) == 0:
            return None
        res = cur = ListNode(lst[0])
        for i in range(1, len(lst)):
            cur.next = ListNode(lst[i])
            cur = cur.next
        return res

Given an integer num, repeatedly add all its digits until the result has only one digit, and return it.

class Solution:
    def addDigits(self, num: int) -> int:
        while len(str(num)) != 1:
            res = 0
            for i in range(len(str(num))):
                print(f"{i=},{num=}")
                res += int(str(num)[i])
            num = res
        return num

Write a function that reverses a string. The input string is given as an array of characters s.

You must do this by modifying the input array in-place with O(1) extra memory.

class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        s.reverse()

Given an integer n, return true if it is a power of two. Otherwise, return false.

An integer n is a power of two, if there exists an integer x such that n == 2x.

class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        if n == 0:
            return False
        if n == 1:
            return True
        if n % 2 == 0:
            while n % 2 == 0:
                n = n / 2
            if n == 1:
                return True
        return False

Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.

You must implement a solution with a linear runtime complexity and use only constant extra space.

class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        lst = []
        for element in nums:
            if element in lst:
                lst.remove(element)
            else:
                lst.append(element)
        return lst[0]

Given the head of a singly linked list, reverse the list, and return the reversed list.

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head is None:
            return None
        lst = []
        while head:
            lst.append(head.val)
            head = head.next
        lst.reverse()
        print(f"{lst=}")
        res = cur = ListNode(lst[0])
        for i in range(1, len(lst)):
            cur.next = ListNode(lst[i])
            cur = cur.next
        return res

Given an array nums of size n, return the majority element.

The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        dic = {}
        for element in nums:
            if element not in dic.keys():
                dic[element] = 1
            else:
                dic[element] += 1
            if dic[element] > len(nums) // 2:
                return element

A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.

Given a string s, return true if it is a palindrome, or false otherwise.

class Solution:
    def isPalindrome(self, s: str) -> bool:
        if s == " ":
            return True
        cap = ['7','5','6','3','4','9','8','1','2','0','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
        low = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
        s = s.lower()
        i = 0
        while i < len(s):
            if s[i] not in cap and s[i] not in low:
                s = s[:i] + s[i + 1:]
                # print(f"{s=}")
                i -= 1
            i += 1
        new_string = ''
        for i in range(len(s)):
            new_string = s[i] + new_string
        if s == new_string:
            return True
        else:
            return False

Given a callable function f(x, y) with a hidden formula and a value z, reverse engineer the formula and return all positive integer pairs x and y where f(x,y) == z. You may return the pairs in any order.

"""
   This is the custom function interface.
   You should not implement it, or speculate about its implementation
   class CustomFunction:
       # Returns f(x, y) for any given positive integers x and y.
       # Note that f(x, y) is increasing with respect to both x and y.
       # i.e. f(x, y) < f(x + 1, y), f(x, y) < f(x, y + 1)
       def f(self, x, y):
  
"""

class Solution:

    def findSolution(self, customfunction: 'CustomFunction', z: int) -> List[List[int]]:
        y = z
        x = 1
        lst = []
        while x <= z and y >= 1:
            value = customfunction.f(x,y)
            if value < z:
                x += 1
            elif value == z:
                lst.append([x,y])
                x += 1
                y -= 1
            else:
                y -= 1
        return lst

You are climbing a staircase. It takes n steps to reach the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

class Solution:
    def climbStairs(self, n: int) -> int:
        if n <= 3:
            return n
        p1 = 3
        p2 = 2
        cur = 0
        for _ in range(3,n):
            cur = p1 + p2
            p2 = p1
            p1 = cur
        return cur

Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        
        def is_mirror(left, right):
            if left is None and right is None:
                return True
            if left is None or right is None or left.val != right.val:
                return False
            return is_mirror(left.left, right.right) and is_mirror(left.right, right.left)
        
        return is_mirror(root, root)

Given the root of a binary tree, return the inorder traversal of its nodes' values.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        lst = []
        self.helper(root, lst)
        return lst
    
    def helper(self, root, lst):
        if root:
            self.helper(root.left, lst)
            lst.append(root.val)
            self.helper(root.right, lst)

Given the root of a binary tree, return its maximum depth.

A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1

Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        if not nums:
            return None
        mid = len(nums) // 2
        root = TreeNode(nums[mid])
        root.left = self.sortedArrayToBST(nums[:mid])
        root.right = self.sortedArrayToBST(nums[mid + 1:])
        return root

Given a binary tree, determine if it is height-balanced.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        
        def helper(root):
            if not root:
                return [True, 0]
            left_balanced, left_height = helper(root.left)
            right_balanced, right_height = helper(root.right)
            isBalanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1
            return [isBalanced, 1 + max(left_height, right_height)]
        
        return helper(root)[0]

Given an integer numRows, return the first numRows of Pascal's triangle.

class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        if numRows == 0:
            return []
        if numRows == 1:
            return [[1]]
        prev = self.generate(numRows - 1)
        new = [1] * numRows
        for i in range(1, numRows - 1):
            new[i] = prev[-1][i - 1] + prev[-1][i]
        prev.append(new)
        return prev

Given head, the head of a linked list, determine if the linked list has a cycle in it.

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        fast = head
        slow = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
            if slow == fast:
                return True
        return False

You are given an array prices where prices[i] is the price of a given stock on the ith day.

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        buy = prices[0]
        profit = 0

        for i in range(len(prices)):
            if prices[i] < buy:
                buy = prices[i]

            profit = max(profit, prices[i] - buy)

        return profit

Given the roots of two binary trees p and q, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        if p is None and q is None:
            return True
        if p is None or q is None:
            return False
        if p.val == q.val:
            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
        return False

Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if root is None:
            return False
        if root.left is None and root.right is None:
            return targetSum == root.val
        left_sum = self.hasPathSum(root.left, targetSum - root.val)
        right_sum = self.hasPathSum(root.right, targetSum - root.val)
        return left_sum or right_sum

Given a binary tree, find its minimum depth.

The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0
        if root.left is None and root.right is None:
            return 1
        if root.left is None and root.right:
            return self.minDepth(root.right) + 1
        if root.right is None and root.left:
            return self.minDepth(root.left) + 1
        if root.right and root.left:
            return min(self.minDepth(root.left) + 1, self.minDepth(root.right) + 1)

Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle.

class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        ans = [1,1]
        if rowIndex == 0:
            return [1]
        if rowIndex == 1:
            return ans
        prev = self.getRow(rowIndex - 1)
        res = [1] * (rowIndex + 1)
        for i in range(1, rowIndex):
            print(f"{i=}")
            res[i] = prev[i - 1] + prev[i]
        return res

Given two strings s and t, determine if they are isomorphic.

class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        d = {}
        lst = []
        for i in range(len(s)):
            d[s[i]] = t[i]
        for i in range(len(s)):
            if d[s[i]] != t[i]:
                return False
        for i in d.values():
            if i in lst:
                return False
            lst.append(i)
        return True

Given the root of a binary tree, return the postorder traversal of its nodes' values.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans = []
        def helper(root):
            if root is None:
                return ans
            helper(root.left)
            helper(root.right)
            ans.append(root.val)
            return ans
        return helper(root)

Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.

class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        nums = sorted(nums)
        for i in range(1, len(nums)):
            if nums[i] == nums[i - 1]:
                return True
        return False

Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.

class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
        set1 = set()
        for i in range(len(nums)):
            if nums[i] in set1:
                return True
            set1.add(nums[i])
            if len(set1) > k:
                set1.remove(nums[i - k])

        return False

Given the root of a binary tree, invert the tree, and return its root.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        a = root
        self.invert(a)
        return root
    def invert(self, a):
        if a is None:
            return 
        a.left, a.right = a.right, a.left
        self.invert(a.left)
        self.invert(a.right)

You are given a sorted unique integer array nums.

A range [a,b] is the set of all integers from a to b (inclusive).

Return the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.

class Solution:
    def summaryRanges(self, nums: List[int]) -> List[str]:
        ans = []
        if not nums:
            return ans
        first = nums[0]
        for i in range(1, len(nums) + 1):
            if i == len(nums) or nums[i] != nums[i - 1] + 1:
                if first == nums[i - 1]:
                    ans.append(str(first))
                else:
                    ans.append(f"{first}->{nums[i - 1]}")
                if i < len(nums):
                    first = nums[i]
        return ans

Given the head of a singly linked list, return true if it is a palindrome or false otherwise.

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:
        string = ''
        while head:
            string = string + str(head.val)
            head = head.next
        if string == string[::-1]:
            return True
        return False

Given the root of a binary tree, return all root-to-leaf paths in any order.

A leaf is a node with no children.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        def helper(node, path):
            if not node.right and not node.left:
                paths.append(path + str(node.val))
                return
            if node.right:
                helper(node.right, path + str(node.val) + '->')
            if node.left:
                helper(node.left, path + str(node.val) + '->')
        paths = []
        if root:
            helper(root, '')
        return paths

Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.

Note that you must do this in-place without making a copy of the array.

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        for i in range(len(nums)):
            if nums[i] == 0:
                nums.remove(0)
                nums.append(0)

Given a pattern and a string s, find if s follows the same pattern.

Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s. Specifically:

Each letter in pattern maps to exactly one unique word in s.
Each unique word in s maps to exactly one letter in pattern.
No two letters map to the same word, and no two words map to the same letter.

class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        if pattern == s and len(pattern) == len(s) and len(pattern) > 1:
            return False
        word = []
        d = {}
        lst = []
        j = 0
        s += ' '
        for i in range(len(s)):
            if s[i] == ' ':
                word.append(s[j:i])
                j = i + 1
        print(word)
        if len(pattern) > len(word):
            return False
        for i in range(len(pattern)):
            d[pattern[i]] = word[i]
        print(d)
        print(d.keys())
        for i in d.keys():
            if len(d.keys()) == 1 and len(d.values()) == 1 and len(word) != 1:
                return False
            if d[i] in lst:
                if len(word) >= len(d.keys()):
                    return False
            lst.append(d[i])
        for i in range(len(pattern)):
            print(i)
            print(d[pattern[i]])
            if d[pattern[i]] != word[i]:
                return False
        return True

Given an integer n, return true if it is a power of three. Otherwise, return false.

An integer n is a power of three, if there exists an integer x such that n == 3x.

class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        if n <= 0:
            return False
        while n % 3 == 0:
            n = n // 3
        if n == 1:
            return True
        return False

You are playing the following Nim Game with your friend:

Initially, there is a heap of stones on the table.
You and your friend will alternate taking turns, and you go first.
On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.
The one who removes the last stone is the winner.
Given n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false.

class Solution:
    def canWinNim(self, n: int) -> bool:
        while n > 4:
            n = n % 4
        if n == 1 or n == 2 or n == 3:
            return True
        else:
            return False

Given an integer n, return true if it is a power of four. Otherwise, return false.

An integer n is a power of four, if there exists an integer x such that n == 4x.

class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        if n <= 0:
            return False
        if n == 1:
            return True
        while n >= 4:
            n = n / 4
        return n == 1

Given a string s, reverse only all the vowels in the string and return it.

The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.

class Solution:
    def reverseVowels(self, s: str) -> str:
        vowels = ['a','e','i','o','u','A','E','I','O','U']
        lst = []
        for i in range(len(s)):
            if s[i] in vowels:
                lst.append(s[i])
        lst = lst[::-1]
        for i in range(len(s)):
            if s[i] in vowels:
                s = s[:i] + lst[0] + s[i + 1:]
                lst.pop(0)
        return s

Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.

class Solution:
    def firstUniqChar(self, s: str) -> int:
        string = ''
        for i in range(len(s)):
            if s[i] not in s[i + 1:] and s[i] not in string:
                return i
            string += s[i]
        return -1

You are given two strings s and t.

String t is generated by random shuffling string s and then add one more letter at a random position.

Return the letter that was added to t.

class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        s = ''.join(sorted(s))
        t = ''.join(sorted(t))
        print(s)
        print(t)
        for i in range(len(s)):
            if s[i] != t[i]:
                if s[i] in t[i:]:
                    return t[i]
        return t[-1]

Given an integer n, return a string array answer (1-indexed) where:

answer[i] == "FizzBuzz" if i is divisible by 3 and 5.
answer[i] == "Fizz" if i is divisible by 3.
answer[i] == "Buzz" if i is divisible by 5.
answer[i] == i (as a string) if none of the above conditions are true.

class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        lst = []
        i = 1
        while i <= n:
            lst.append(str(i))
            i += 1
        for i in range(len(lst)):
            if int(lst[i]) % 3 == 0 and int(lst[i]) % 5 == 0:
                lst[i] = 'FizzBuzz'
            elif int(lst[i]) % 5 == 0:
                lst[i] = 'Buzz'
            elif int(lst[i]) % 3 == 0:
                lst[i] = 'Fizz'
        return lst

Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.

class Solution:
    def thirdMax(self, nums: List[int]) -> int:
        lst = []
        nums = sorted(nums)
        count = 0
        nums = nums[::-1]
        if len(nums) <= 2:
            return nums[0]
        for i in range(len(nums)):
            if nums[i] not in lst:
                count += 1
                lst.append(nums[i])
            if count == 3:
                return nums[i]
        if count < 3:
            return nums[0]

Given a binary array nums, return the maximum number of consecutive 1's in the array.

class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        lst = []
        count = 0
        for i in range(len(nums)):
            if nums[i] == 1:
                count += 1
            if nums[i] == 0:
                lst.append(count)
                count = 0
            if i == len(nums) - 1:
                lst.append(count)
        return max(lst)

The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,

F(0) = 0, F(1) = 1
F(n) = F(n - 1) + F(n - 2), for n > 1.
Given n, calculate F(n).

class Solution:
    def fib(self, n: int) -> int:
        if n == 0:
            return 0
        if n == 1:
            return 1
        return self.fib(n - 1) + self.fib(n - 2)

A web developer needs to know how to design a web page's size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:

The area of the rectangular web page you designed must equal to the given target area.
The width W should not be larger than the length L, which means L >= W.
The difference between length L and width W should be as small as possible.
Return an array [L, W] where L and W are the length and width of the web page you designed in sequence.

class Solution:
    def constructRectangle(self, area: int) -> List[int]:
        if area == 1:
            return [1,1]
        lst = []
        for i in range(1, area):
            if area // i * i == area:
                lst.append([area // i, i])
        return lst[len(lst) // 2]

A binary watch has 4 LEDs on the top to represent the hours (0-11), and 6 LEDs on the bottom to represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.

class Solution:
    def readBinaryWatch(self, turnedOn: int) -> List[str]:
        ans = []
        for h in range(12):
            for m in range(60):
                hOnes = bin(h).count('1')
                mOnes = bin(m).count('1')
                if hOnes + mOnes == turnedOn:
                    ans.append(f'{h}:{m:02d}')
        return ans

You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.

class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -> int:
        ans = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    ans += 4
                    if i > 0 and grid[i - 1][j] == 1:
                        ans -= 2
                    if j > 0 and grid[i][j - 1] == 1:
                        ans -= 2
        return ans

Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.

class Solution:
    def longestPalindrome(self, s: str) -> int:
        ans = 0
        character_set = set()
        for char in s:
            if char in character_set:
                character_set.remove(char)
                ans += 2
            else:
                character_set.add(char)
        if character_set:
            ans += 1
        return ans

Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.

class Solution:
    def countBits(self, n: int) -> List[int]:
        ans = [0] * (n + 1)
        for i in range(1, n + 1):
            ans[i] = ans[i // 2] + (i & 1)
        return ans

Given a string s, return the string after replacing every uppercase letter with the same lowercase letter.

class Solution:
    def toLowerCase(self, s: str) -> str:
        return s.lower()

The Hamming distance between two integers is the number of positions at which the corresponding bits are different.

Given two integers x and y, return the Hamming distance between them.

class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        xor = x ^ y
        return bin(x ^ y).count('1')

Given an integer num, return a string of its base 7 representation.

class Solution:
    def convertToBase7(self, num: int) -> str:
        if num == 0:
            return '0'
        sign = '-' if num < 0 else ''
        num = abs(num)
        digits = []
        while num:
            digits.append(str(num % 7))
            num = num // 7
        return sign + ''.join((reversed(digits)))

Reverse bits of a given 32 bits unsigned integer.

class Solution:
    def reverseBits(self, n: int) -> int:
        result = 0
        for _ in range(32):
            bit = n & 1
            result = (result << 1) | bit
            n >>= 1
        return result

Given a positive integer n, write a function that returns the number of set bits in its binary representation (also known as the Hamming weight).

class Solution:
    def hammingWeight(self, n: int) -> int:
        return bin(n).count('1')

The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.

For example, The integer 5 is "101" in binary and its complement is "010" which is the integer 2.
Given an integer num, return its complement.

class Solution:
    def findComplement(self, num: int) -> int:
        numbits = num.bit_length()
        mask = (1 << numbits) - 1
        return num ^ mask

Given a n-ary tree, find its maximum depth.

"""
# Definition for a Node.
class Node:
    def __init__(self, val: Optional[int] = None, children: Optional[List['Node']] = None):
        self.val = val
        self.children = children
"""

class Solution:
    def maxDepth(self, root: 'Node') -> int:
        if root is None:
            return 0
        maxdepth = 0
        for child in root.children:
            maxdepth = max(self.maxDepth(child), maxdepth)
        return maxdepth + 1

Given an integer array nums of 2n integers, group these integers into n pairs (a1, b1), (a2, b2), ..., (an, bn) such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum.

class Solution:
    def arrayPairSum(self, nums: List[int]) -> int:
        nums = sorted(nums)
        sum = 0
        lst = []
        for i in range(0, len(nums), 2):
            lst.append([nums[i],nums[i + 1]])
        for element in lst:
            sum += min(element)
        return sum

You are given two binary trees root1 and root2.

Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.

Return the merged tree.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root1:
            return root2
        if not root2:
            return root1
        root1.val += root2.val
        root1.left = self.mergeTrees(root1.left, root2.left)
        root1.right = self.mergeTrees(root1.right, root2.right)
        return root1

Given the root of an n-ary tree, return the preorder traversal of its nodes' values.

Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)

"""
# Definition for a Node.
class Node:
    def __init__(self, val: Optional[int] = None, children: Optional[List['Node']] = None):
        self.val = val
        self.children = children
"""

class Solution:
    def preorder(self, root: 'Node') -> List[int]:
        ans = []
        self.traverse(root, ans)
        return ans
    def traverse(self, node, ans):
        if not node:
            return
        ans.append(node.val)
        for child in node.children:
            self.traverse(child, ans)

Given the root of a binary tree, return the length of the diameter of the tree.

The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.

The length of a path between two nodes is represented by the number of edges between them.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        def diameter(node, res):
            if not node:
                return 0
            left = diameter(node.left, res)
            right = diameter(node.right, res)
            res[0] = max(res[0], left + right)
            return max(left , right) + 1
        res = [0]
        diameter(root,res)
        return res[0]

Given the root of an n-ary tree, return the postorder traversal of its nodes' values.

Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)

"""
# Definition for a Node.
class Node:
    def __init__(self, val: Optional[int] = None, children: Optional[List['Node']] = None):
        self.val = val
        self.children = children
"""

class Solution:
    def postorder(self, root: 'Node') -> List[int]:
        if root is None:
            return []
        res = []
        def dfs(root):
            for x in root.children:
                dfs(x)
            res.append(root.val)
        dfs(root)
        return res

Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.

class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        n = bin(n)
        s = str(n)
        for i in range(len(s)):
            if i == len(s) - 1:
                return True
            if s[i] != s[i + 1]:
                continue
            else:
                return False
        return True

We have two special characters:

The first character can be represented by one bit 0.
The second character can be represented by two bits (10 or 11).
Given a binary array bits that ends with 0, return true if the last character must be a one-bit character.

class Solution:
    def isOneBitCharacter(self, bits: List[int]) -> bool:
        if bits == [0]:
            return True
        while bits:
            if len(bits) > 1:
                if [bits[0], bits[1]] == [1,0]:
                    bits.pop(0)
                    bits.pop(0)
            if bits == [1]:
                return False
            if bits == [0]:
                return True
            if len(bits) > 1:
                if [bits[0], bits[1]] == [1,1]:
                    bits.pop(0)
                    bits.pop(0)
            if bits == []:
                return False
            if bits[0] == 0:
                bits.pop(0)
        return True

Given an m x n matrix, return true if the matrix is Toeplitz. Otherwise, return false.

A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same elements.

class Solution:
    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:
        row = len(matrix)
        column = len(matrix[0])
        row1 = matrix[0]
        for i in range(1, row):
            mat = matrix[i]
            for j in range(1, column):
                if row1[j - 1] != mat[j]:
                    return False
            row1 = mat
        return True

You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels.

Letters are case sensitive, so "a" is considered a different type of stone from "A".

class Solution:
    def numJewelsInStones(self, jewels: str, stones: str) -> int:
        lst = []
        count = 0
        for i in range(len(jewels)):
            lst.append(jewels[i])
        for i in range(len(stones)):
            if stones[i] in lst:
                count += 1
        return count

Given a 2D integer array matrix, return the transpose of matrix.

The transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.

class Solution:
    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:
        return list(map(list, zip(*matrix)))

Given an array of points on the X-Y plane points where points[i] = [xi, yi], return the area of the largest triangle that can be formed by any three different points. Answers within 10-5 of the actual answer will be accepted.

class Solution:
    def largestTriangleArea(self, points: List[List[int]]) -> float:
        area = 0
        length = len(points)
        for i in range(0, length):
            x1, y1 = points[i]
            for j in range(i + 1, length):
                x2, y2 = points[j]
                for q in range(j + 1, length):
                    x3, y3 = points[q]
                    curr = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))
                    if curr > area:
                        area = curr
        return area

Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.

To flip an image horizontally means that each row of the image is reversed.

For example, flipping [1,1,0] horizontally results in [0,1,1].
To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.

For example, inverting [0,1,1] results in [1,0,0].

class Solution:
    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:
        lst1 = []
        lst2 = []
        for element in image:
            element = element[::-1]
            for element1 in element:
                if element1 == 0:
                    element1 = 1
                else:
                    element1 = 0
                lst2.append(element1)
        while lst2:
            lst1.append(lst2[0:len(image[0])])
            lst2 = lst2[len(image[0]):]
        return lst1

Given head which is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number.

Return the decimal value of the number in the linked list.

The most significant bit is at the head of the linked list.

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def getDecimalValue(self, head: Optional[ListNode]) -> int:
        s = ''
        while head:
            s += str(head.val)
            head = head.next
        return int(s, 2)

A binary tree is uni-valued if every node in the tree has the same value.

Given the root of a binary tree, return true if the given tree is uni-valued, or false otherwise.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isUnivalTree(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        if root.left and root.right:
            if root.val == root.left.val and root.val == root.right.val:
                return self.isUnivalTree(root.left) and self.isUnivalTree(root.right)
            else:
                return False
        elif root.left and not root.right:
            if root.val == root.left.val:
                return self.isUnivalTree(root.left)
            else:
                return False
        elif not root.left and not root.right:
            return True
        else:
            if root.val == root.right.val:
                return self.isUnivalTree(root.right)
            else:
                return False

Given a square matrix mat, return the sum of the matrix diagonals.

Only include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal.

class Solution:
    def diagonalSum(self, mat: List[List[int]]) -> int:
        sum = 0
        for i in range(len(mat)):
            sum += mat[i][i]
        for i in range(len(mat)):
            sum += mat[len(mat) - 1 - i][i]
        if len(mat) % 2 != 0:
            sum -= mat[len(mat) // 2][len(mat) // 2]
        return sum

Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.

class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        count = 0
        for element in grid:
            for i in range(len(element)):
                if element[i] < 0:
                    count += 1
        return count

The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.

For example, The integer 5 is "101" in binary and its complement is "010" which is the integer 2.
Given an integer n, return its complement.

class Solution:
    def bitwiseComplement(self, n: int) -> int:
        binary = bin(n)[2:]
        for i in range(len(binary)):
            if binary[i] == '0':
                binary = binary[:i] + '1' + binary[i + 1:]
            else:
                binary = binary[:i] + '0' + binary[i + 1:]
        return int(binary, 2)

You are given a binary array nums (0-indexed).

We define xi as the number whose binary representation is the subarray nums[0..i] (from most-significant-bit to least-significant-bit).

For example, if nums = [1,0,1], then x0 = 1, x1 = 2, and x2 = 5.
Return an array of booleans answer where answer[i] is true if xi is divisible by 5.

class Solution:
    def prefixesDivBy5(self, nums: List[int]) -> List[bool]:
        s = ''
        lst = []
        for i in range(len(nums)):
            s = s + str(nums[i])
            lst.append(int(s, 2) % 5 == 0)
        return lst

Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a leaf value sequence.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:
        def findSequence(root, res):
            if not root:
                return
            if not root.left and not root.right:
                res.append(root.val)
            findSequence(root.left, res)
            findSequence(root.right, res)
        root1seq = []
        root2seq = []
        findSequence(root1, root1seq)
        findSequence(root2, root2seq)
        return root1seq == root2seq

Given an m x n matrix of distinct numbers, return all lucky numbers in the matrix in any order.

A lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column.

class Solution:
    def luckyNumbers(self, matrix: List[List[int]]) -> List[int]:
        lst = []
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if matrix[i][j] == min(matrix[i]) and matrix[i][j] == max(matrix[z][j] for z in range(len(matrix))):
                    lst.append(matrix[i][j])
        return lst

You are given an integer n and an integer start.

Define an array nums where nums[i] = start + 2 * i (0-indexed) and n == nums.length.

Return the bitwise XOR of all elements of nums.

class Solution:
    def xorOperation(self, n: int, start: int) -> int:
        lst = []
        i = 0
        ans = 0
        while n != 0:
            n -= 1
            lst.append(start + 2 * i)
            i += 1
        for i in range(len(lst)):
            ans = ans ^ lst[i]
        return ans

Given a binary string s ​​​​​without leading zeros, return true​​​ if s contains at most one contiguous segment of ones. Otherwise, return false.

class Solution:
    def checkOnesSegment(self, s: str) -> bool:
        if '0' not in s:
            return True
        while s[0] == '1':
            s = s[1:]
        if '1' in s:
            return False
        else:
            return True

You are given the root of a binary tree where each node has a value 0 or 1. Each root-to-leaf path represents a binary number starting with the most significant bit.

For example, if the path is 0 -> 1 -> 1 -> 0 -> 1, then this could represent 01101 in binary, which is 13.
For all leaves in the tree, consider the numbers represented by the path from the root to that leaf. Return the sum of these numbers.

The test cases are generated so that the answer fits in a 32-bits integer.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:
        def dfs(node, path):
            if not node:
                return 0
            path = (path << 1) + node.val
            if not node.left and not node.right:
                return path
            return dfs(node.left, path) + dfs(node.right, path)
        return dfs(root, 0)

There is a hidden integer array arr that consists of n non-negative integers.

It was encoded into another integer array encoded of length n - 1, such that encoded[i] = arr[i] XOR arr[i + 1]. For example, if arr = [1,0,2,1], then encoded = [1,2,3].

You are given the encoded array. You are also given an integer first, that is the first element of arr, i.e. arr[0].

Return the original array arr. It can be proved that the answer exists and is unique.

class Solution:
    def decode(self, encoded: List[int], first: int) -> List[int]:
        lst = [first]
        for i in range(len(encoded)):
            lst.append(first ^ encoded[i])
            first = first ^ encoded[i]
        return lst

Given an integer n (in base 10) and a base k, return the sum of the digits of n after converting n from base 10 to base k.

After converting, each digit should be interpreted as a base 10 number, and the sum should be returned in base 10.

class Solution:
    def sumBase(self, n: int, k: int) -> int:
        string = ''
        res = 0
        while n != 0:
            string += str(n % k)
            n = n // k
        for i in range(len(string)):
            res += int(string[i])
        return res

You are given a string s consisting only of the characters '0' and '1'. In one operation, you can change any '0' to '1' or vice versa.

The string is called alternating if no two adjacent characters are equal. For example, the string "010" is alternating, while the string "0100" is not.

Return the minimum number of operations needed to make s alternating.

class Solution:
    def minOperations(self, s: str) -> int:
        count1 = 0
        count2 = 0
        ans1 = '01'
        ans2 = '10'
        if len(s) % 2 == 0:
            bin_str1 = ans1 * int(len(s) / 2)
        else:
            bin_str1 = ans1 * int(len(s) / 2) + '0'
        if len(s) % 2 == 0:
            bin_str2 = ans2 * int(len(s) / 2)
        else:
            bin_str2 = ans2 * int(len(s) / 2) + '1'
        for i in range(len(s)):
            if s[i] != bin_str1[i]:
                count1 += 1
            if s[i] != bin_str2[i]:
                count2 += 1
        return min(count1, count2)

Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:
        res = []
        def findaverage(node, level):
            if not node:
                return
            if level > len(res):
                res.append([node.val, 1])
            else:
                res[level - 1][0] += node.val
                res[level - 1][1] += 1
            findaverage(node.left, level + 1)
            findaverage(node.right, level + 1)
        findaverage(root, 1)
        return [i[0] / i[1] for i in res]

Given the array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn].

Return the array in the form [x1,y1,x2,y2,...,xn,yn].

class Solution:
    def shuffle(self, nums: List[int], n: int) -> List[int]:
        s = 0
        lst = []
        while s != n:
            lst += [nums[s], nums[s + n]]
            s += 1
        return lst

Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1.

Sort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2. Elements that do not appear in arr2 should be placed at the end of arr1 in ascending order.

class Solution:
    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:
        lst = []
        for i in range(len(arr2)):
            while arr2[i] in arr1:
                arr1.remove(arr2[i])
                lst.append(arr2[i])
        arr1 = sorted(arr1)
        for i in range(len(arr1)):
            if arr1[i] not in arr2:
                lst.append(arr1[i])
        return lst

Given a date, return the corresponding day of the week for that date.

The input is given as three integers representing the day, month and year respectively.

Return the answer as one of the following values {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}.

class Solution:
    def dayOfTheWeek(self, day: int, month: int, year: int) -> str:
        return date(year, month, day).strftime('%A')
